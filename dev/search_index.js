var documenterSearchIndex = {"docs":
[{"location":"parameters/#Parameters-in-NuclearToolkit","page":"Optional parameters","title":"Parameters in NuclearToolkit","text":"","category":"section"},{"location":"parameters/","page":"Optional parameters","title":"Optional parameters","text":"Here is the summary of optional parameters, which can be specified by users like this:","category":"page"},{"location":"parameters/","page":"Optional parameters","title":"Optional parameters","text":"make_chiEFTint(;fn_params=\"your_parameter_file.jl\")","category":"page"},{"location":"parameters/","page":"Optional parameters","title":"Optional parameters","text":"If you do not specify the optional argument fn_params, the pacakege tries to read optional_parameters.jl in the current path.","category":"page"},{"location":"parameters/","page":"Optional parameters","title":"Optional parameters","text":"For ChiEFTint\nn_mesh::Int64, number of momentum mesh \npmax_fm::Float64, maximum pmax in fm^-1\nemax::Int64, emax quanta\nNnmax::Int64, Nnmax quanta\nchi_order::Int64, order of chiral EFT potenteial (0:LO 1:NLO 2:NNLO 3:N3LO 4:N4LO)\ncalc_NN::Bool, calculate NN part\ncalc_3N::Bool, calculate eff2n (2n3n) part\ncoulomb::Bool, calculate Coulomb term    \ncalc_EperA::Bool, calculate E/A\nhw::Float64 hbar omega in MeV\nsrg::Bool, SRG transformation (NN-only)\nsrg_lambda::Float64, resolution scale for SRG in fm^-1\ntbme_fmt::String file format of matrix-elements of free-space interaction. \"snt\" or \"snt.bin\" is supported\nfn_tbme::String file name of output interaction\npottype::String potential type (em500n3lo,emn500n3lo,emn500n4lo) \nkF::Float64 Fermi momentum for 2n3n in fm^-1\nFor IMSRG\nsmax::Float64 max flow parameter s\ndsmax::Float64 maximum step size for IMSRG flow\nmaxnormOmega::Float64 tol for norm of IMSRG generator\ndenominatorDelta::Float64 denominator delta for multi-shell interaction\nBetaCM::Float64  beta for center-of-mass correction\nmagnusamethod::String specifying IMSRG solver (\"\" or \"split\" => multi-step splitting (as a default), \"no-split\" or \"NS\"=> no-splitting)","category":"page"},{"location":"howtouse/#How-to-use-NuclearToolkit.jl","page":"HowToUse","title":"How to use NuclearToolkit.jl","text":"","category":"section"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"In this page, we explain the main interfaces of NuclearToolkit.jl and sample codes.","category":"page"},{"location":"howtouse/#Generate-Chiral-EFT-potentials","page":"HowToUse","title":"Generate Chiral EFT potentials","text":"","category":"section"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"The ChiEFTint subblock provides the codes to generate nucleon-nucleon (NN) potentials from Chiral effective field theory. You can specify the options through optional_parameters.jl, if it exists in the working directory. A sample of optional_parameters.jl is available on the repository, and see the Optional parameters page for more details.","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"The main API is make_chiEFTint() and the sample code is given below.","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"#1). generate NN interaction file in snt or snt.bin format\nmake_chiEFTint()\n\n#2). 1). & showing how much time and memory has been used\nmake_chiEFTint(;is_show=true)\n\n#3). You don't need to write out the snt/snt.bin file, but want to calibrate or sample the LECs in the 3NF using HFMBPT.\n#    You have to specify the number of itertions, target nuclei, optimizer:\nmake_chiEFTint(;itnum=5,nucs=[\"O16\"],optimizer=\"MCMC\")","category":"page"},{"location":"howtouse/#Working-on-a-super-computer","page":"HowToUse","title":"Working on a super-computer","text":"","category":"section"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"In NuclearToolkit.jl, many-nodes calculation utilizing MPI.jl is supported for LECs calibration with HF-MBPT.","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"A sample script, let's call mpisample.jl, can be something like this:","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"using NuclearToolkit\nmake_chiEFTint(;itnum=500,nucs=[\"O16\"],optimizer=\"MCMC\",MPIcomm=true)","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"Then, you can run with, e.g., 20 nodes:","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"mpirun -np 20 mpisample.jl","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"When working on a working node (w/o permissions to access ~/), overwrite the JULIA_DEPOT_PATH by export JULIA_DEPOT_PATH=\"PATH_TO_JULIA_DEPOT\".","category":"page"},{"location":"howtouse/#HF-MBPT-calculations","page":"HowToUse","title":"HF-MBPT calculations","text":"","category":"section"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"You can evaluate ground state properties by the so-called Hartree-Fock many-body perturbation theory (HF-MBPT). The hf_main function in HartreeFock is the main interface.","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"You must specify target nuclei, snt file (generated by chiEFTint), harmonic oscillator parameter hw, model space size emax.","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"hw = 20; emax=4\nsntf = \"path_to_your.snt\"\n#1). you can evaluate HF-MBPT(3) estimate of g.s. energy of the target nuclus\nnucs = [\"O16\",\"Ca40\"]\nhf_main(nucs,sntf,hw,emax)\n\n#2). nucs can be both string and [Z,N] array\nnucs = [ [8,8], [20,20]]\nhf_main(nucs,sntf,hw,emax)\n\n#3). specify Rp2 operators if you need\nnucs = [\"O16\",\"Ca40\"]\nhf_main(nucs,sntf,hw,emax;Operators=[\"Rp2\"])","category":"page"},{"location":"howtouse/#IMSRG-calculations","page":"HowToUse","title":"IMSRG calculations","text":"","category":"section"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"One can perform in-medium similarity renormalization group (IM-SRG) calculations by specifing the optional argument doIMSRG=true:","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"hw = 20; emax=4\nnucs = [\"He4\",\"O16\"]\nsntf = \"path_to_your.snt\"\nhf_main(nucs,sntf,hw,emax;doIMSRG=true,Operators=[\"Rp2\"])","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"Since the IM-SRG is one of the post-HF methods, it uses the same interface for HF(-MBPT).","category":"page"},{"location":"howtouse/#VS-IMSRG-calculations","page":"HowToUse","title":"VS-IMSRG calculations","text":"","category":"section"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"You can also perform valence-space IMSRG (VS-IMSRG) decoupling to derive shell-model interactions for a target model space. The API is similar to the IMSRG case, but you must specify core, ref, and vspace.","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"hw = 20; emax=4\ncore = \"O16\"; vspace=\"sd-shell\", ref=\"core\"\nnucs = [\"Mg24\"]\nsntf = \"path_to_your.snt\"\n\n#1). derivation of sd-shell interaction on top of the 16O core w/o target/ensemble normal ordering\nhf_main(nucs,sntf,hw,emax;doIMSRG=true,core=core,ref=\"core\",vspace=\"sd-shell\")\n\n#2). derivation of sd-shell interaction on top of the 16O core w/ target/ensemble normal ordering\nnucs = [\"Mg24\"]\nhf_main(nucs,sntf,hw,emax;doIMSRG=true,core=core,ref=\"nucl\",vspace=\"sd-shell\")","category":"page"},{"location":"howtouse/#valence-shell-model-calculations","page":"HowToUse","title":"valence shell-model calculations","text":"","category":"section"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"You need to specify the effective interaction (in snt format), number of eigenvalues, and target total J to perform shell-model calculations.","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"hw = 20; emax=4;\nvs_sntf = \"vsimsrg_sd-shell_coreO16refO16_O16_hw20e4_Delta0.0.snt\"\nn_eigen=10\ntargetJ=[]\n\n#1). 10 lowest states\nmain_sm(vs_sntf,\"Mg24\",n_eigen,targetJ)\n\n#2). 10 lowest states with J = 0\ntargetJ = [0]\nmain_sm(vs_sntf,\"Mg24\",n_eigen,targetJ)","category":"page"},{"location":"howtouse/","page":"HowToUse","title":"HowToUse","text":"The codes are rather optimized to repeat smaller calculations (up to 48Cr on the pf shell) iteratively, (i.e., memory-hogging compared to other shell-model codes). For nuclei in a larger model space than the pf shell, it is recommended to use the KSHELL by Prof. Noritaka Shimizu.","category":"page"},{"location":"ChiEFTint/#ChiEFTint","page":"ChiEFTint","title":"ChiEFTint","text":"","category":"section"},{"location":"ChiEFTint/","page":"ChiEFTint","title":"ChiEFTint","text":"Functions needed to generate nucleon-nucleon (NN) potential from Chiral EFT.","category":"page"},{"location":"ChiEFTint/","page":"ChiEFTint","title":"ChiEFTint","text":"The parameters needed for chiEFTint are specified through optional_parameters.jl or the optional argument fn_params=[PATH_TO_FILE] in main API, make_chiEFTint().","category":"page"},{"location":"ChiEFTint/","page":"ChiEFTint","title":"ChiEFTint","text":"Modules = [NuclearToolkit]\nPages = [\"chiEFTint/main_chiEFTint.jl\",\n         \"chiEFTint/contact.jl\",\n         \"chiEFTint/pionexchange.jl\",\n         \"chiEFTint/angmom_algebra.jl\",\n         \"chiEFTint/misc_plt_io.jl\",\n         \"chiEFTint/threebodyforce.jl\",\n         \"chiEFTint/calibration.jl\",\n         \"chiEFTint/renorm.jl\",\n         \"chiEFTint/valence.jl\",         \n         \"chiEFTint/eff3nf.jl\",\n\t     \"chiEFTint/read_me3j.jl\",\n         \"chiEFTint/dict_LECs.jl\"\n]","category":"page"},{"location":"ChiEFTint/#NuclearToolkit.Calc_Deuteron-Tuple{NuclearToolkit.ChiralEFTobject, Any}","page":"ChiEFTint","title":"NuclearToolkit.Calc_Deuteron","text":"Calc_Deuteron(chiEFTobj::ChiralEFTobject,to;io=stdout)\n\nFunction to calculate deuteron binding energy.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Gauss_Legendre-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.Gauss_Legendre","text":"Gauss_Legendre(xmin,xmax,n;eps=3.e-16)\n\nCalculating mesh points x and weights w for Gauss-Legendre quadrature. This returns x, w.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Legendre-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.Legendre","text":"Legendre(n,x)\n\nfunction to calculate Legendre polynomial P_n(x)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.QL-Tuple{Any, Int64, Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.QL","text":"QL(z,J::Int64,ts,ws)\n\nTo calculate Legendre functions of second kind, which are needed for pion-exchange contributions, by Gauss-Legendre quadrature.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Rnl_all_ab-NTuple{5, Any}","page":"ChiEFTint","title":"NuclearToolkit.Rnl_all_ab","text":"Rnl_all_ab(lmax,br,n_mesh,xr_fm)\n\nReturns array for radial functions (prop to generalized Laguerre polynomials) HO w.f. in momentum space. Rnlk(l,n,k)=sqrt(br) * R(n,L,Z) *Z with Z=br*k (k is momentum in fm^-1)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Vrel-Tuple{NuclearToolkit.ChiralEFTobject, Any}","page":"ChiEFTint","title":"NuclearToolkit.Vrel","text":"Vrel(chiEFTobj::ChiralEFTobject,to)\n\nTo define V in two-particle HO basis.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.calc_Vmom!-Tuple{NuclearToolkit.chiEFTparams, Vararg{Any, 13}}","page":"ChiEFTint","title":"NuclearToolkit.calc_Vmom!","text":"calc_Vmom!(pnrank,V12mom,tdict,xr,LEC,LEC2,l,lp,S,J,pfunc,to;is_3nf=false)\n\ncalc. NN-potential for momentum mesh points\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.calc_coulomb-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.calc_coulomb","text":"calculating coulomb contribution in HO base. Results are overwritten to Vcoulomb\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.construct_chiEFTobj-NTuple{6, Any}","page":"ChiEFTint","title":"NuclearToolkit.construct_chiEFTobj","text":"construct_chiEFTobj(do2n3ncalib,itnum,optimizer,MPIcomm,io,to;fn_params=\"optional_parameters.jl\")\n\nIt returns \n\nchiEFTobj::ChiralEFTobject parameters and arrays to generate NN (+2n3n) potentials. See also struct ChiralEFoObject.\nOPTobj (mutable) struct for LECs calibrations. It can be LHSobject/BOobject/MCMCobject/MPIMCMCobject struct.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.def_sps_snt-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.def_sps_snt","text":"def_sps_snt(emax,target_nlj)\n\nDefining dicts for single particle states. One can truncate sps by specifying target_nlj, but it is usually empty so this function is usually not used.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.freg-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.freg","text":"freg(p,pp,n;Lambchi=500.0)\n\nthe regulator function used for NN or 2n3n contribution, Eq.(4.63) in EM's review: f(pp) = exp  -(pLambda)^2n -(pLambda)^2n  \n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.genLaguerre-Tuple{Int64, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.genLaguerre","text":"genLaguerre(n::Int,alpha,x)\n\nreturns generalized Laguaerre polynomials, L^alpha_n(x)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.get_twobody_channels-Tuple{Int64, Any, Any, Any, Any, Int64, Int64}","page":"ChiEFTint","title":"NuclearToolkit.get_twobody_channels","text":"get_twq_2b(emax,kh,kn,kl,kj,maxsps,jab_max)\n\nreturns infos, izs_ab, nTBME\n\ninfos::Vector{Vector{Int64}} information of two-body channeles: { [T_z,parity,J,dim] } \nizs_ab::Vector{Vecrtor{Int64}} two-body kets: { [iza,ia,izb,ib] } where iz* stuff is isospin (-1 or 1) and i* stuff is label of sps.\n\nFor example, [-1,1,1,1] corresponds to |p0s1/2 n0s1/2>.\n\nnTBME::Int # of TBMEs\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.hw_formula-Tuple{Int64, Int64}","page":"ChiEFTint","title":"NuclearToolkit.hw_formula","text":"hw_formula(A,fnum)\n\nempirical formula for harmonis oscillator parameter hw by mass number A fnum=2: for sd-shell, Ref. J. Blomqvist and A. Molinari, Nucl. Phys. A106, 545 (1968).\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.make_chiEFTint-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.make_chiEFTint","text":"make_chiEFTint(;is_show=false,itnum=1,writesnt=true,nucs=[],optimizer=\"\",MPIcomm=false,corenuc=\"\",ref=\"nucl\",Operators=[],fn_params=\"optional_parameters.jl\",write_vmom=false,do_svd=false)\n\nThe interface function in chiEFTint. This generates NN-potential in momentum space and then transforms it in HO basis to give inputs for many-body calculations. The function is exported and can be simply called make_chiEFTint() in your script. \n\nOptional arguments: Note that these are mainly for too specific purposes, so you do not specify these.\n\nis_show::Bool to show TimerOutputs\nitnum::Int number of iteration for LECs calibration with HFMBPT\nwritesnt::Bool, to write out interaction file in snt (KSHELL) format. julia writesnt = false case can be usefull when you iteratively calculate with different LECs.\nnucs target nuclei used for LECs calibration with HFMBPT\noptimizer::String method for LECs calibration. \"MCMC\",\"LHS\",\"BayesOpt\" are available\nMPIcomm::Bool, to carry out LECs sampling with HF-MBPT and affine inveriant MCMC\nOperators::Vector{String} specifies operators you need to use in LECs calibrations\nfn_params::String path to file specifying the optional parameters\nwrite_vmom::Bool to write out in vmom partial wave channels\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.make_sp_state-Tuple{NuclearToolkit.chiEFTparams}","page":"ChiEFTint","title":"NuclearToolkit.make_sp_state","text":"make_sp_state(chiEFTparams;io=stdout)\n\nDefining the two-body channels or kets.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prepare_2b_pw_states-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.prepare_2b_pw_states","text":"prepare_2b_pw_states(;io=stdout)\n\npreparing two-body partical-wave channels, <Lp,S,J| |L,S,J>. For example, [pnrank,L,Lp,S,J] = [0, 0, 2, 1, 1] corresponds to proton-neutron 3S1-3D1 channel.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.read_LECs-Tuple{Any}","page":"ChiEFTint","title":"NuclearToolkit.read_LECs","text":"read_LECs(pottype)\n\nread LECs for a specified potential type, em500n3lo,em500n3lo,emn500n4lo, nnlosat.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.single_Rnl-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.single_Rnl","text":"simply calculate R_nl(pb) = sqrt frac2 n b^3Gamma(n+l+32) (pb)^l e^-p^2b^22 L^l+12_n(p^2b^2) \n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.LO-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.LO","text":"LO(chiEFTobj,to)\n\nCalculate Leading Order (LO), Q^0 contact term.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.N3LO-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.N3LO","text":"N3LO(chiEFTobj,to)\n\nCalculate Next-to-next-to-next-to Leading Order (N3LO), Q^4 contact term.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.N4LO-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.N4LO","text":"N4LO(chiEFTobj,to;n_reg=2)\n\nCalculate Next-to-next-to-next-to-next-to Leading Order (N4LO) contact term.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.NLO-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.NLO","text":"NLO(chiEFTobj,to;n_regulator=2)\n\nCalculate Next to Leading Order (NLO), Q^2 contact term. LECs=>C23S1,C23P0,C21P1,C23P1,C21S0,C23SD1,C23DS1,C23P2\n\nThe power for exponential regulator n_reg is 2 (default), For 3P1 channel, n_reg=3 is used as in the R.Machleidt's fortran code. I don't know the reason, but the LECs in EMN potential) may have been determined with n_reg=3 potential.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.tpe_ch","page":"ChiEFTint","title":"NuclearToolkit.tpe_ch","text":"9xnthreads matrix to store sum of each tpe channal, C/T/S/LS/SigmaL\n\n\n\n\n\n","category":"type"},{"location":"ChiEFTint/#NuclearToolkit.OPEP-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.OPEP","text":"OPEP(chiEFTobj,to;pigamma=false)\n\ncalc. One-pion exchange potential in the momentum-space\n\nReference: R. Machleidt, Phys. Rev. C 63 024001 (2001).\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Vc_term-NTuple{12, Any}","page":"ChiEFTint","title":"NuclearToolkit.Vc_term","text":"Vc_term(chi_order,w,tw2,q2,Lq,Aq,nd_mpi,c1,c2,c3,Fpi2,LoopObjects;EMN=false,usingMachleidt=true,ImVerbose=false,calc_TPE_separately=false)\n\nNNLO: EM NNLO eq.(4.13), EKMN Eq.(C1) + relativistic correction Eq.(D7)\nN3LO: \nf1term c^2_i: EM Eq.(D.1), EKMN Eq.(D1)\nf6term c_iM_N: EM Eq.(D.4)\n\nnote: Note\nWhile Eq.(D7) in EKMN paper are given with the statement \"given by [1]\" refering the EM review, Eq.(D7) doesn't match neither Eq.(4.13) nor Eq.(4.13)+Eq.(4.21). Since the LECs in EKMN paper are determined through the Eq.(D7) and this correction term gives minor effect, we use Eq.(D7). If usingMachleidt is set false, one can restore original expression in EM review.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Vls_term-NTuple{9, Any}","page":"ChiEFTint","title":"NuclearToolkit.Vls_term","text":"Vls_term(chi_order,w,tw2,q2,Lq,Aq,nd_mpi,c2,Fpi2;EMN=false)\n\nnote: Note\nIn EMN interaction, relativistic corrections are counted as N3LO.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Vt_term-NTuple{11, Any}","page":"ChiEFTint","title":"NuclearToolkit.Vt_term","text":"Vt_term(chi_order,w,q2,k2,Lq,Aq,nd_mpi,r_d145,Fpi4)\n\nNLO: EM Eq.(4.10)\nNNLO: EM Eq.(4.15) & Eq.(4.22) => it_pi term\nN3LO: EM Eq.(D.11) (1/M^2_N` term), Eq.(D.23) (2-loop term)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Wc_term-NTuple{14, Any}","page":"ChiEFTint","title":"NuclearToolkit.Wc_term","text":"Wc_term(chi_order,LoopObjects,w,tw2,q2,k2,Lq,Aq,nd_mpi,c4,r_d12,r_d3,r_d5,Fpi2;EMN=false,useMachleidt=true,calc_TPE_separately=false)\n\nnote: Note\nEMN Eq.(D8) doesn't match the expression in EM review, Eq.(4.14) nor Eq(4.14)+Eq.(4.22). Since the LECs in EKMN paper are determined through the Eqs.(D8) and these difference gives minor effect, we use EMN eq.(D8).\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Ws_term-NTuple{9, Any}","page":"ChiEFTint","title":"NuclearToolkit.Ws_term","text":"Ws_term(chi_order,LoopObjects,w,q2,Lq,Aq,nd_mpi,c4,Fpi2;EMN=false,useMachleidt=true,calc_TPE_separately=false)\n\nNNLO: EM Eq.(4.16) & Eq.(4.24) => it_pi term\nN3LO: EM Eq.(D.2) (c^2_i term), Eq.(D.6) (c_i/M_Nterm), Eq.(D.12) (1/M^2_N`` term), Eq.(D.27) (2-loop term)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.calc_LqAq-NTuple{5, Any}","page":"ChiEFTint","title":"NuclearToolkit.calc_LqAq","text":"calc_LqAq(w,q,nd_mpi,usingSFR,LamSFR)\n\nTo calculate L(q) and A(q) appear in TPE contributions; L(q)=EM Eq.(4.11), A(q)=EM Eq.(D.28). If usingSFR, Lq&Aq are replaced by Eqs.(2.24)&(C3) in EKMN paper.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.cib_lsj_opep","page":"ChiEFTint","title":"NuclearToolkit.cib_lsj_opep","text":"Ref: R. Machleidt, Phys. Rev. C 63, 024001 (2001).\n\nFor pi-gamma correction term, which is introduced in e.g. EM500 interaction, one needs to evaluate integrals in (B11)~ terms in an explicit manner.\n\n\n\n\n\n","category":"function"},{"location":"ChiEFTint/#NuclearToolkit.fac_pig","page":"ChiEFTint","title":"NuclearToolkit.fac_pig","text":"pi-gamma correction Eq.(4) of U. van Kolck et al., Phys. Rev. Lett. 80, 4386 (1998).\n\nNote that 1/(1+beta^2) is ommited, since it is also included in the OPEP contribution, i.e. one needs to consider only the difference other than this factor.\n\n\n\n\n\n","category":"function"},{"location":"ChiEFTint/#NuclearToolkit.n3lo_ImVc!-NTuple{6, Any}","page":"ChiEFTint","title":"NuclearToolkit.n3lo_ImVc!","text":"n3lo_ImVc!(muvec,V,mpi,Fpi)\n\nThe expression can be found in eq.(D3) of EKMN paper.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.n3lo_ImVsVt!-NTuple{7, Any}","page":"ChiEFTint","title":"NuclearToolkit.n3lo_ImVsVt!","text":"n3lo_ImVsVt!(Vt,mpi,Fpi,r_d145,mudomain,ts,ws)\n\nThe expression can be found in eq.(D5) of EKMN paper and the second term in eq.(D5) is ommited. Note that LECs bard_14-bard_15 is given as d145 in NuclearToolkit.jl. Vt can be used for Vs=-q2*Vt\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.n3lo_ImWc!-NTuple{10, Any}","page":"ChiEFTint","title":"NuclearToolkit.n3lo_ImWc!","text":"n3lo_ImWc!(V,mpi,Fpi,r_d12,r_d3,r_d5,r_d145,mudomain,ts,ws)\n\nThe expression can be found in eq.(D4) of EKMN paper.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.n3lo_ImWsWt!-NTuple{6, Any}","page":"ChiEFTint","title":"NuclearToolkit.n3lo_ImWsWt!","text":"n3lo_ImWsWt!(Wt,mpi,Fpi,mudomain,ts,ws)\n\nThe expression can be found in eq.(D6) of EKMN paper. Wt can be used for Ws=-q2*Wt\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.precalc_2loop_integrals-NTuple{14, Any}","page":"ChiEFTint","title":"NuclearToolkit.precalc_2loop_integrals","text":"V_CS(q) = -frac2q^6pi int^tildeLambda_nm_pi dmu \nfracmathrmIm V_CS(imu)mu^5 (mu^2+q^2) \nV_T(q) = frac2q^4pi  int^tildeLambda_nm_pi dmu \n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.tpe-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.tpe","text":"tpe(chiEFTobj,to::TimerOutput)\n\nFunction to calculate two-pion exchange terms up to N3LO(EM) or N4LO(EMN)\n\nThe power conting schemes for EM/EMN are different; The 1M_N correction terms appear at NNLO in EM and at N4LO in EMN.\n\nReferences\n\nEM: R. Machleidt and D.R. Entem Physics Reports 503 (2011) 1–7\nEMKN: D. R. Entem, N. Kaiser, R. Machleidt, and Y. Nosyk, Phys. Rev. C 91, 014002 (2015).\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.tpe_for_givenJT-NTuple{17, Any}","page":"ChiEFTint","title":"NuclearToolkit.tpe_for_givenJT","text":"tpe_for_givenJT(chiEFTobj,LoopObjects,Fpi2,tmpLECs,J,pnrank,ts,ws,fff,dwn,nd_mpi,xr,pjs_para,gis_para,opfs_para,f_idx,tVs_para,lsj,tllsj_para,tdict,V12mom,tmpsum,to;calc_TPE_sep=true)\n\nCalculating TPE contribution in a given momentum mesh point.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.HObracket_d6j-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Float64, Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.HObracket_d6j","text":"HObracket(nl, ll, nr, lr, n1, l1, n2, l2, Lam, d::Float64,dWs,tkey9j,dict9j_HOB,to)\n\nTo calc. generalized harmonic oscillator brackets (HOBs), n_lell_ln_rell_rLambdan_1ell_1n_2ell_2Lambda_d from the preallocated 9j dictionary.\n\nReference:\n\n[1] B.Buck& A.C.merchant, Nucl.Phys. A600 (1996) 387-402\n[2] G.P.Kamuntavicius et al., Nucl.Phys. A695 (2001) 191-201\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.TMtrans-Tuple{NuclearToolkit.ChiralEFTobject, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.TMtrans","text":"TMtrans(chiEFTobj::ChiralEFTobject,dWS,to;writesnt=true)\n\nFunction to carry out Talmi-Moshinsky transformation for NN interaction in HO space and to write out an sinput file.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.get_canonical_order_6j-NTuple{6, Int64}","page":"ChiEFTint","title":"NuclearToolkit.get_canonical_order_6j","text":"Function to get canonical order of 6j-symbol arguments:\n\nleft beginmatrix j_1  j_3   j_5  j_2  j_4  j_6endmatrix right \n\nThis may not bring speed up though... The canonical order is defined as follows:\n\nSince the 6j-symbol is invariant under permutation of any two columns, we can always re-order the columns such that j_1+j_2 leq j_3+j_4 leq j_5+j_6.\nIf sum of two columns are equal, we re-order columns based on j_col_score, using the minimum j value of the two columns.\nSince the 6j-symbol is invariant under permutation rows for any two columns, we can always re-order the rows such that j_1 leq j_2 j_3 leq j_4 j_5 leq j_6 if any column have the same j.\nIf the elements of any column are different from each other, the relation between upper and lower j will always be either vee vee vee  vee landland or landlandland  land vee vee. We can always re-order the rows such that the landlandland or vee vee vee is satisfied.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.get_nkey6_shift-NTuple{6, Int64}","page":"ChiEFTint","title":"NuclearToolkit.get_nkey6_shift","text":"Unlike other wigner symbols, constructing CG coefficients enconter the case with negative indices. One way to avoid this is to use the following function to get hash key for the CG coefficients. This function asssume all j is >= -3\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.get_nkey_from_abcdarr-Tuple{Any}","page":"ChiEFTint","title":"NuclearToolkit.get_nkey_from_abcdarr","text":"get_nkey_from_abcdarr(tkey;ofst=1000)\n\nTo get integer key from an Int array (with length greater than equal 4)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.kinetic_ob-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.kinetic_ob","text":"kinetic_ob(nlj1, nlj2)\n\ncalc. kinetic one-body contribution \\langle j_1 |T/\\habr\\omega| j_2 \\rangle\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.kinetic_tb-NTuple{6, Any}","page":"ChiEFTint","title":"NuclearToolkit.kinetic_tb","text":"kinetic_tb(nljtz1, nljtz2, nljtz3, nljtz4, J, dWS)\n\ncalc. kinetic two-body contribution langle j_1j_2 -p_1 p_2hbaromega j_3j_4rangle_J using preallocated 6j-symbols.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prep_dWS2n-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.prep_dWS2n","text":"Function to construct dWS2n struct, CG-coefficients and Wigner symbols for the given parameters.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prep_dWS3N-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.prep_dWS3N","text":"it doesn't work for now\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prep_dcg_spin-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.prep_dcg_spin","text":"Function to prepare CG coefficient for recoupling of spin (isospin). The resultant dictionary is used for e.g. to use Three-body matrix elements. Note that the all indices are doubled.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prep_wsyms-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.prep_wsyms","text":"prep_wsyms()\n\npreparing Clebsch-Gordan coefficients for some special cases: cg1s = (1,0,l,0|l',0), cg2s = (2,0,l,0|l',0)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.red_nabla_j-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.red_nabla_j","text":"red_nabla_j(nlj1,nlj2,d6j,key6j)\n\nreturns b langle j  nabla  j_2rangle Note that l_1l_2 in nlj1&nlj2 are not doubled.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.red_nabla_l-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.red_nabla_l","text":"red_nabla_l(n1,l1,n2,l2)\n\nreturns b langle n_1l_1 nabla n_2l_2 rangle in l-reduced matrix element.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.spherical_harmonics-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.spherical_harmonics","text":"associated Legendre Polynomials are calculated with AssociatedLegendrePolynomials.jl\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.vtrans-Tuple{NuclearToolkit.ChiralEFTobject, Vararg{Any, 17}}","page":"ChiEFTint","title":"NuclearToolkit.vtrans","text":"vtrans(chiEFTobj,pnrank,izz,ip,Jtot,iza,ia,izb,ib,izc,ic,izd,id,nljsnt,V12ab,t5v,to)\n\nFunction to calculate V in pn-formalism:\n\nlangle abJTzV cdJTz rangle = N_ab N_cd  sum_Lambda S Lambda S sum_nell N Lsum_nell N L  \nsum_J_mathrmrelJ_mathrmrel LambdaLambda hatShatS hatJ_mathrmrelhatJ_mathrmrel \nhatj_a hatj_b hatj_c hatj_d\n(-1)^ell + S + J_mathrmrel + L (-1)^ell + S + J_mathrmrel + L\nlangle n N  (ell L)Lambda S J n_a n_b  (ell_a ell_b)Lambda (tfrac12tfrac12)S J rangle_d=1\nlangle n N  (ell L)Lambda S J n_c n_d  (ell_c ell_d)Lambda (tfrac12tfrac12)S J rangle_d=1\nleft beginmatrix ell_a  ell_b  Lambda  12  12  S  j_a  j_b  J endmatrix right \nleft beginmatrix ell_c  ell_d  Lambda  12  12  S  j_c  j_d  J endmatrix right \nleft beginmatrix L  ell  Lambda  S  J  J_mathrmrel endmatrix right\nleft beginmatrix L  ell  Lambda  S  J  J_mathrmrel endmatrix right \nlangle nell S J_mathrmrel TV_mathrmNNnell S J_mathrmrel Trangle\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.wigner9j-NTuple{9, Any}","page":"ChiEFTint","title":"NuclearToolkit.wigner9j","text":"wigner9j(j1,j2,j3,j4,j5,j6,j7,j8,j9)\n\ncalculate Wigner's 9j symbols, all j should be given as integer (0,1,...) or halfinteger (3/2, 3//2,...)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.IsospinDot-Tuple{Int64, Int64, Int64, Any}","page":"ChiEFTint","title":"NuclearToolkit.IsospinDot","text":"<τ2・τ3> = 6 (-1)^(t+t'+T+1/2) *wigner6j(t,t',1,1/2,1/2,1/2) * wigner6j(t,t',1,1/2,1/2,T) \n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.anti_op_isospin-Tuple{NuclearToolkit.params3b, Vararg{Any, 19}}","page":"ChiEFTint","title":"NuclearToolkit.anti_op_isospin","text":"anti_op_isospin(params,n12,l12,s12,j12,t12,n3,l3,j3,n45,l45,s45,j45,t45,n6,l6,j6,jtot,ttot,to)\n\nFunction to calc. matrix element of antisymmetrizer.   Detailed derivation can be found in e.g., Eq.(3.119) of Master Thesis by Joachim Langhammer (2010), TUDarmstadt.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.nonlocal_regulator_3NF-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.nonlocal_regulator_3NF","text":"EGM => Eq.(19) in E.Epelbaum et al., PRC 66, 064001(2002). Navratil => Eq.(11) in P.Navratil Few Body Syst. (2007) 41:117-140 Lambda in given in MeV\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prep_Rnls-Tuple{Any}","page":"ChiEFTint","title":"NuclearToolkit.prep_Rnls","text":"prepare R_nl(r) with 2n12+l12 + 2N + L = e12 + e3 = N3 <= N3max Note that twice of reduced mass is used in this function\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.gz","page":"ChiEFTint","title":"NuclearToolkit.gz","text":"function used for proposals in Affine invariant MCMC\n\n\n\n\n\n","category":"function"},{"location":"ChiEFTint/#NuclearToolkit.prepOPT-Tuple{NuclearToolkit.LECs, Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.prepOPT","text":"cand:: candidate point given by LatinHypercubeSampling observed:: list of index of cand which has been observed unobserved:: rest candidate indices history:: array of [logprior,logllh,logpost] for i=1:num_cand\n\nfor GP\n\nKtt,Kttinv,Ktp,L:: matrix needed for GP calculation yt:: mean value of training point, to be mean of initial random point  yscale:: mean&std of yt that is used to scale/rescale data     acquis:: vector of acquisition function values pKernel:: hypara for GP kernel, first one is tau and the other ones are correlation lengths adhoc=> tau =1.0, l=1/domain size\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.sample_AffineInvMCMC","page":"ChiEFTint","title":"NuclearToolkit.sample_AffineInvMCMC","text":"sample_AffineInvMCMC(numwalkers::Int, x0::Matrix{Float64},nstep::Integer, thinning::Integer,a::Float64=2.)\n\nFunction to carry out a parameter sampling with Affince invariant MCMC method.\n\nReference: Goodman & Weare, \"Ensemble samplers with affine invariance\", Communications in Applied Mathematics and Computational Science, DOI: 10.2140/camcos.2010.5.65, 2010.\n\n\n\n\n\n","category":"function"},{"location":"ChiEFTint/#NuclearToolkit.RKstep-NTuple{7, Any}","page":"ChiEFTint","title":"NuclearToolkit.RKstep","text":"RKstep(T,Ho,eta,R,faceta,fRK,Ht)\n\nwrapper function to calc. a Runge-Kutta (RK) step\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.SRG-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.SRG","text":"SRG(xr,wr,V12mom,dict_pwch,to)\n\nSimilarity Renormalization Group (SRG) transformation of NN interaction in CM-rel momentum space.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.commutator-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.commutator","text":"commutator(A,B,R,fac)\n\nwrapper function to overwrite R by fac*(AB-BA)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.srg_RK4-NTuple{11, Any}","page":"ChiEFTint","title":"NuclearToolkit.srg_RK4","text":"srg_RK4(Ho,T,Ht,Hs,eta,R,sSRG,face,ds,numit,to; r_err=1.e-8,a_err=1.e-8,tol=1.e-6)\n\nto carry out SRG transformation with RK4\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prep_QWs-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.prep_QWs","text":"prep_QWs(chiEFTobj,xr,ts,ws)\n\nreturns struct QLs, second kind Legendre functions, Eqs.(B1)-(B5) in [Kohno2013]. Note that QLs.QLdict is also used in OPEP to avoid redundant calculations. Reference:  [Kohno2013] M.Kohno Phys. Rev. C 88, 064005(2013)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prep_integrals_for2n3n-NTuple{5, Any}","page":"ChiEFTint","title":"NuclearToolkit.prep_integrals_for2n3n","text":"prep_integrals_for2n3n(chiEFTobj,xr,ts,ws,to)\n\npreparing integrals and Wigner symbols for density-dependent 3NFs:\n\nFis::Fis_2n3n vectors {F0s,F1s,F2s,F3s}, Eqs.(A13)-(A16) in [Kohno2013].\nQWs:: second kind Legendre functions, Eqs.(B1)-(B5) in [Kohno2013].\nwsyms:: Wingner symbols with specific j used for both 2n and 2n3n.\n\nReference:   [Kohno2013] M.Kohno Phys. Rev. C 88, 064005(2013)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.Get3BME_ISO-NTuple{19, Any}","page":"ChiEFTint","title":"NuclearToolkit.Get3BME_ISO","text":"Function to get the 3BME from the vector v3bme. To this end, we need to calculate the index of the 3BME in the vector v3bme from given Jab,Jde,J2,tab,tde,T,a,b,c,d,e,f.\n\nSince the dict for 3BME, the order if set so that a>=b>=c, d>=e>=f, one needs to be careful to get the correct index for the 3BME.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.allocate_3bme","page":"ChiEFTint","title":"NuclearToolkit.allocate_3bme","text":"Allocating 3BME vector and dictionary for the indices. Note that the dimension of v3bme is the one that is used for the 3BME (for modelspace) instead of the number of elements in the input ThBME file.\n\n\n\n\n\n","category":"function"},{"location":"ChiEFTint/#NuclearToolkit.count_me3jgz-Tuple{NuclearToolkit.sps_3Blab}","page":"ChiEFTint","title":"NuclearToolkit.count_me3jgz","text":"Counting the offset for the 3BME indices.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.count_nreads-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.count_nreads","text":"Since we gonna store in isospin formalism, we use only proton part.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.get_dict_idx_to_snt-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.get_dict_idx_to_snt","text":"While the snt format is given ascending order for ell and j the 3BME is stored in descending order for ell and j. Hence, we need to reorder the indices for the 3BME. Note that this is ad hoc and not guaranteed to work for all cases.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.read_me3jgz-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.read_me3jgz","text":"read_me3jgz(fn, count_ME_file, to; verbose)\n\n\nFunction to read me3j.gz using GZip. The values are stored in a vector ThBME. The ordering of ThBME is not considered here.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.sort_3_orbits-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.sort_3_orbits","text":"The (re)order is done with only odd(tz=-1) indices. abc=0, bca=1, cab=2, acb=3, bac=4, cba=5\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.dict_em500n3lo-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.dict_em500n3lo","text":"dict_em500n3lo\n\nreturns vector&dict. for EM500N3LO: Entem-Machleidt interaction upto N3LO with 500 MeV cutoff \n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.dict_emn500n3lo-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.dict_emn500n3lo","text":"dict_emn500n3lo\n\nreturns vector&dict. for EMN500N3LO: Entem-Machleidt-Nosyk interaction upto N3LO with 500 MeV cutoff \n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.dict_emn500n4lo-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.dict_emn500n4lo","text":"dict_emn500n4lo()\n\nreturns vector&dict. for EMN500N4LO: Entem-Machleidt-Nosyk interaction upto N4LO with 500 MeV cutoff \n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint/#NuclearToolkit.prep_valsidxs_dLECs!-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.prep_valsidxs_dLECs!","text":"prep_valsidxs_dLECs!(vals,idxs,dLECs)\n\noverwrites vals and idxs, which are to be used in e.g., MCMC algorithms, by dict for LECs dLECs.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#IMSRG","page":"IMSRG","title":"IMSRG","text":"","category":"section"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"Files in src/IMSRG.jl for IM-SRG calculations:","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"imsrg_util.jl: contains main and util functions \ncommutator.jl: functions to calculate commutators and BCH transform to carry out IMSRG flow with Magnus expansion\nvalencespace.jl: functions for Valence-space IM-SRG (VS-IMSRG) calculations to derive shell-model effective interactions/operators","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"Since we use the so-called Magnus formulation of IMSRG flow, Omega","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"H(s) = e^Omega(s)H(0)e^-Omega(s) \ne^Omega(s+ds) = e^eta(s)dse^Omega(s)","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"is needed to explicitly calculate the flow generator eta. See e.g. Annual Review of Nuclear and Particle Science 69, 307-362 for more details.","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"In the package, temporary binary files for Omega are genereted in flowOmega directory (which will be made if not available). Although users do not need to read or write these binary files in normal use, the contents of the binary files are described for specific uses and development, e.g. re-start IMSRG flow from the temporary files.","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"A temporary file is generated like flowOmega/Omega_1234He4_1.bin. This contains","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"number of single particle basis (Int64), which is assumbed to be common between proton and neutron.\nOne-body matrix element for protons and neutrons (Matrix{Float64})\nnumber of two-body channels (Int64)\ndimensions of each channel (Vector{Int64})\nTwo-body matrix element for protons and neutrons (Vector{Matrix{Float64}})","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"Note that the all matrix elements are written in row-major order (I know Julia is column-major language).","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"","category":"page"},{"location":"IMSRG/","page":"IMSRG","title":"IMSRG","text":"Modules = [NuclearToolkit]\nPages = [\"IMSRG.jl/commutator.jl\",\n         \"IMSRG.jl/imsrg_util.jl\",\n         \"IMSRG.jl/valencespace.jl\"]","category":"page"},{"location":"IMSRG/#NuclearToolkit.BCH_Product-Union{Tuple{Op}, Tuple{Op, Op, Op, Op, Op, Vector{Int64}, Vector{Float64}, NuclearToolkit.chan1b, NuclearToolkit.chan2bD, NuclearToolkit.HamiltonianNormalOrdered, Any, Any, NuclearToolkit.PandyaObject, Any}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.BCH_Product","text":"BCH_Product(X::Op,Y::Op,Z::Op,tmpOp::Op,Nested::Op,ncomm::Vector{Int64},norms::Vector{Float64},Chan1b::chan1b,Chan2bD::chan2bD,HFobj::HamiltonianNormalOrdered,dictMono,d6j_lj,PandyaObj::PandyaObject,to;tol=1.e-4) where Op <:Operator\n\nreturns Z  to satisfy: e^Z = e^X e^Y.\n\nZ is calculated with Baker–Campbell–Hausdorff (BCH) formula: Z = X + Y + sum^infty_k=1 ad^(k)_Omega(eta) Z = X + Y + 12X Y  + 112 XXY + 112 YYX -124 YXXY -1720 YYYYX -1720 XXXXY +\n\nFor IMSRG flow of H(s), X=eta(s) ds, Y=Omega(s), and Z=Omega(s+ds)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.BCH_Transform-Union{Tuple{Op}, Tuple{Op, Op, Op, Op, Op, Any, Any, NuclearToolkit.chan1b, NuclearToolkit.chan2bD, NuclearToolkit.HamiltonianNormalOrdered, Any, Any, NuclearToolkit.PandyaObject, Any}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.BCH_Transform","text":"BCH_Transform(Omega,O0,Os,tOp,Nested,ncomm,norms,Chan1b,Chan2bD,HFobj,dictMono,d6j_lj,PandyaObj,to;tol=1.e-9,maxit=50,verbose=false)\n\nUpdate Os via e^ABe^-A =B+AB+12AAB+13AAAB+ Note that OstOpNested are set zero.\n\nOmega: Omega(s+ds)\nO0: O(s=0)\nOs: O(s+ds)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.Bernoulli_number-Tuple{Int64}","page":"IMSRG","title":"NuclearToolkit.Bernoulli_number","text":"Bernoulli_number(k::Int64)::Float64\n\nReturn the k-th Bernoulli number. Some special cases are listed below \n\nB(0) = 1\nB(1) = -1/2. In some literature, B(1) = 1/2.\nB(2) = 1/6\nB(2n+1) = 0 (for n >=1)\n\nFor others, see the references A000367 and A002445.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.OpCommutator!-Union{Tuple{Op}, Tuple{Op, Op, Op, NuclearToolkit.HamiltonianNormalOrdered, NuclearToolkit.chan1b, NuclearToolkit.chan2bD, Any, Any, NuclearToolkit.PandyaObject, Any}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.OpCommutator!","text":"OpCommutator!(X::Op,Y::Op,ret::Op,HFobj,Chan1b,Chan2bD,dictMono,d6j_lj,PandyaObj,to) where{Op <: Operator}\n\noverwrite ret operator by the commutator XY\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.calcZbar!-NTuple{11, Any}","page":"IMSRG","title":"NuclearToolkit.calcZbar!","text":"calcZbar!(Xbar,Ybar,PhaseMat,PhaseMatY,tmpMat,hy,nph_kets,nKets_cc,Zlefthalf,Zrighthalf,hz)\n\nXbar: (nKets_cc, 2*nph_kets) matrix or SubArray\nYbar: (2*nph_kets,nKets_cc) matrix or SubArray\nPhaseMatY: (nph_kets,nKets_cc) matrix or SubArray\nZbar: (nKets_cc, 2*nKets_cc) matrix or SubArray\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.comm111ss!-Union{Tuple{Op}, Tuple{Op, Op, Op}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.comm111ss!","text":"comm111ss!(X,Y,ret;inifac=1.0)\n\nreturns X_1Y_1\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.comm121ss!-Union{Tuple{Op}, Tuple{Op, Op, Op, NuclearToolkit.HamiltonianNormalOrdered, NuclearToolkit.chan1b, Any, NuclearToolkit.PandyaObject}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.comm121ss!","text":"comm121ss!(X,Y,ret,HFobj,Chan1b,Chan2b,dictMono,PandyaObj)\n\nreturns X_1Y_2 - Y_1X_2, whose elements are given as\n\nX_1Y_2_ij = frac12j_i+1sum_ab (n_a barn_b) sum_J (2J+1) (X_ab Y^J_biaj - X_ba Y^J_aibj)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.comm220ss!-Union{Tuple{Op}, Tuple{Op, Op, Op, NuclearToolkit.HamiltonianNormalOrdered, Vector{NuclearToolkit.chan2b}}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.comm220ss!","text":"comm220ss!(X::Op,Y::Op,Z::Op,HFobj::HamiltonianNormalOrdered,Chan2b::Vector{chan2b}) where Op<:Operator\n\nX_2Y_2_0 = 2 sum_J(2J+1) mathrmTr(X_hhpp  Y_pphh)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.comm221ss!-Union{Tuple{Op}, Tuple{Op, Op, Op, NuclearToolkit.HamiltonianNormalOrdered, NuclearToolkit.chan1b, NuclearToolkit.chan2bD, NuclearToolkit.PandyaObject, Any}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.comm221ss!","text":"comm221ss!(X::Op,Y::Op,ret::Op,HFobj::HamiltonianNormalOrdered,Chan1b::chan1b,Chan2bD::chan2bD,PandyaObj::PandyaObject) where Op<:Operator\n\nreturns X_2Y_2_1 - Y_2X_2_1, whose elements are given as\n\nX_2Y_2_ij = 1(2j_i) sum_abcsum_JJ(n_an_bn_c-n_an_bn_c)(X_2ciabY_2abcj-Y_2ciabX_2abcj)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.def_d6j_lj_by_run!-Union{Tuple{Op}, Tuple{Op, Op, NuclearToolkit.HamiltonianNormalOrdered, NuclearToolkit.chan2bD, Any, NuclearToolkit.PandyaObject, Any}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.def_d6j_lj_by_run!","text":"Function to store d6j_lj needed in IMSRGflow. Note that the manipulations in this function are meaningless.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.single_121-NTuple{9, Any}","page":"IMSRG","title":"NuclearToolkit.single_121","text":"single_121(a,b,i,j,o1b,o2bs,sps,key,targetDict;verbose=false)\n\nFunction to calculate 121part X_1Y_2-Y_1X_2 for given i,j and a,b.\n\nsum_J J^2 (o_1abo_2biaj - o_1bao_2aibj)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.GatherOmega-Union{Tuple{Op}, Tuple{Op, Op, Op, Op, Op, Any, Any, Any, Any, NuclearToolkit.chan1b, Vararg{Any, 8}}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.GatherOmega","text":"GatherOmega(Omega,nOmega,gatherer,tmpOp,Nested,H0,Hs,ncomm,norms,Chan1b,Chan2bD,HFobj,IMSRGobj,dictMono,d6j_lj,PandyaObj,maxnormOmega,to)\n\nThis may not be used now.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.Get2bDenominator-NTuple{14, Any}","page":"IMSRG","title":"NuclearToolkit.Get2bDenominator","text":"Get2bDenominator(ch,pnrank,a,b,i,j,na,nb,ni,nj,f,Delta,dictMono,key;verbose=false)\n\nf_aa+f_bb-f_ii-f_jj+G_abij +Delta\n\nwith G_abij = Gamma_abab + Gamma_ijij - (Gamma_aiai + Gamma_bjbj + a leftrightarrow b)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.Gethhph-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.Gethhph","text":"Gethhph(kets,sps)\n\nget idxs for hh/ph kets\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.calc_Eta_atan!-Tuple{NuclearToolkit.HamiltonianNormalOrdered, NuclearToolkit.IMSRGobject, Vector{NuclearToolkit.chan2b}, Any, Any}","page":"IMSRG","title":"NuclearToolkit.calc_Eta_atan!","text":"calc_Eta_atan!(HFobj::HamiltonianNormalOrdered,IMSRGobj::IMSRGobject,Chan2b::Vector{chan2b},dictMono,norms)\n\ncalc. eta(s) with atan generator\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.check_order_Mkey-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.check_order_Mkey","text":"check_order_Mkey(key,pnrank)\n\nreorder key to be key[1] > key[2]\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.flow_Operators-Tuple{Any, Any, Any, Any, NuclearToolkit.chan1b, Vararg{Any, 8}}","page":"IMSRG","title":"NuclearToolkit.flow_Operators","text":"flow_Operators(binfo,HFobj,IMSRGobj,PandyaObj,Chan1b,Chan2bD,d6j_lj,dictMono,Operators,to)\n\nconsistent IMSRG flow of scaler operators (Rp2) using written Omega\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.getNorm-Tuple{NuclearToolkit.Operator, Any, Any, Any}","page":"IMSRG","title":"NuclearToolkit.getNorm","text":"getNorm(O,p_sps,n_sps,Chan2b)\n\nreturns sqrt(norm1b^2 + norm2b^2)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.getNorm1b","page":"IMSRG","title":"NuclearToolkit.getNorm1b","text":"getNorm1b(Mat1b,p_sps,n_sps,verbose=false)\n\nreturns 1bnorm of the given Operator\n\n\n\n\n\n","category":"function"},{"location":"IMSRG/#NuclearToolkit.getNorm2b","page":"IMSRG","title":"NuclearToolkit.getNorm2b","text":"getNorm2b(Mat2b,Chan2b,verbose=false)\n\nreturns 2bnorm of the given Operator\n\n\n\n\n\n","category":"function"},{"location":"IMSRG/#NuclearToolkit.imsrg_main-Tuple{NuclearToolkit.basedat, NuclearToolkit.chan1b, NuclearToolkit.chan2bD, NuclearToolkit.HamiltonianNormalOrdered, Vararg{Any, 6}}","page":"IMSRG","title":"NuclearToolkit.imsrg_main","text":"imsrg_main(binfo::basedat,Chan1b,Chan2bD,HFobj,dictMono,dWS,valencespace,Operators,to; core_generator_type=\"atan\",valence_generator_type=\"shell-model-atan\",denominatorDelta=0.0)\n\nArguments\n\nbinfo::basedat struct basedat(nuc::nuclei,sntf::String,hw::Float,emax::Int)\nChan1b::chan1b struct for one-body stuffs\nChan2bD::chan2bD struct for two-body stuffs (e.g., dict to get idx from JPT)\nHFobj::HamiltonianNormalOrdered struct HNO, which includes info. of HF solution (HF energy, occupation, f,Gamma,...)\ndictMono::Dict dictionary to get Vmonopole\ndWS dictionary of preallocated wigner-symbols\nvalencespace to specify valence space  \nOperators::Vector{String} non-Hamiltonian operators\nto TimerOutput object to measure runtime&memory allocations\n\nOptional Arguments\n\ndelete_Ops if true, delete Operators with current pid after IMSRGflow\ncore_generator_type only the \"atan\" is available\nvalence_generator_type only the \"shell-model-atan\" is available\ndenominatorDelta::Float denominator Delta, which is needed for multi-major shell decoupling\ndebugmode=0: 0: no debug, 1: debug, 2: debug with more info\nrestart_from_files: files to be read for restart 1st one is for IMSRG and 2nd one is for VSIMSRG\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.init_IMSRGobject-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.init_IMSRGobject","text":"init_IMSRGobject(HFobj;smax=500.0,dsmax=0.5,maxnormOmega=0.25,tol=1.e-6,eta_criterion=1.e-6,denominatorDelta=0.0)\n\nConstructor for IMSRGobject\n\nH0::Operator for starting point of BCH product\nH::Operator Hamiltonian H(s)\ns::Vector{Float} current s and ds\nsmax::Float maximum s\ndsmax::Float maximum ds\nmaxnormOmega::Float maximum ||Omega||\neta::Operator generator of IMSRG flow (antihermite Operator)\nOmega::Operator generator of IMSRG flow (antihermite Operator) \neta_criterion::Float ||eta|| to check convergence\ndenominatorDelta::Float64 parameter for multi-major shell decoupling\nn_written_omega::Int # of written Omega by splitting to solve IMSRGflow\nNcomm::Vector{Int} # of commutator evaluated during IMSRG flow\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.init_dictMonopole!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.init_dictMonopole!","text":"init_dictMonopole!(dictMonopole,Chan2b)\n\ninitialize dictMonopole\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.make_PandyaKets-Tuple{Int64, NuclearToolkit.HamiltonianNormalOrdered, Any}","page":"IMSRG","title":"NuclearToolkit.make_PandyaKets","text":"make_PandyaKets(emax,HFobj)\n\nTo prepare \"kets\" for Pandya transformation. For ordinary two-body channels, kets like |i,j=i;J=odd> with `={n,l,j,tz} are hindered, but necessary for Pandya transformation.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.prep_PandyaLookup-Tuple{NuclearToolkit.basedat, NuclearToolkit.HamiltonianNormalOrdered, NuclearToolkit.chan1b, NuclearToolkit.chan2bD}","page":"IMSRG","title":"NuclearToolkit.prep_PandyaLookup","text":"prep_PandyaLookup(binfo::basedat,HFobj::HamiltonianNormalOrdered,Chan1b::chan1b,Chan2bD::chan2bD;rank_J=0,rank_T=0,parity=0,ofst=1000)\n\nconstructor of utils for Pandya transformation and others numbersPandya:[ch,nKetcc,nhh,nph] for ich (channel index of Chan2b_Pandya) \n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.print_flowstatus","page":"IMSRG","title":"NuclearToolkit.print_flowstatus","text":"print_flowstatus(istep,s,ncomm,norms,IMSRGobj)\n\nFunction to print flowstatus s,E0,1b&2b norm for Omega, 1b&2b norm for Eta, Ncomm, nwritten\n\n\n\n\n\n","category":"function"},{"location":"IMSRG/#NuclearToolkit.read_imsrg_parameter!-Tuple{String, NuclearToolkit.IMSRGobject}","page":"IMSRG","title":"NuclearToolkit.read_imsrg_parameter!","text":"read_imsrg_parameter!(fn,IMSRGobj)\n\nFunction to overwrite IMSRGobj from the parameter file fn.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.read_omega_bin!","page":"IMSRG","title":"NuclearToolkit.read_omega_bin!","text":"read_omega_bin!(nw,Op,verbose=false)\n\nread written Omega file and update Op::Operator\n\n\n\n\n\n","category":"function"},{"location":"IMSRG/#NuclearToolkit.set_dictMonopole!-Tuple{Any, Any, Any}","page":"IMSRG","title":"NuclearToolkit.set_dictMonopole!","text":"set_dictMonopole!(dictMonopole,HFobj,H)\n\nTo update dictMonopole pp/pn/nn under H(s=0)/IMSRG H(s)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.set_sps_to_core!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.set_sps_to_core!","text":"set_sps_to_core!(binfo,HFobj)\n\nmodify p_sps.occ, n_sps.occ by the \"core\" nucleus\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.set_sps_to_modelspace!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.set_sps_to_modelspace!","text":"set_sps_to_modelspace!(binfo,HFobj)\n\nmodify occupation by specified model space\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.update_core_in_sps!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.update_core_in_sps!","text":"update_core_in_sps!(binfo,HFobj)\n\nFunction to specify hole/core for sps. This will will be used for target normal ordering\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.write_omega_bin-Tuple{NuclearToolkit.basedat, Vector{NuclearToolkit.chan2b}, Int64, NuclearToolkit.Operator, Float64, Float64}","page":"IMSRG","title":"NuclearToolkit.write_omega_bin","text":"write_omega_bin(binfo,n_written,Omega)\n\nFunction to write temporary binary files of Operator matrix elements, when spliting the flow.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.calc_Eta_smatan!-Tuple{NuclearToolkit.HamiltonianNormalOrdered, Vararg{Any, 4}}","page":"IMSRG","title":"NuclearToolkit.calc_Eta_smatan!","text":"calc_Eta_smatan!(HFobj,IMSRGobj,Chan2b,dictMono,norms)\n\neta(s) with shell-model atan generator to decouple the specified valence space.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.check_array_valencespace-Tuple{Vector{Vector{Int64}}, Any, Any}","page":"IMSRG","title":"NuclearToolkit.check_array_valencespace","text":"check_array_valencespace(valencespace::Vector{Vector{Int64}},HFobj,v)\n\ncheck valence space and overwrtie SingleParticleState.v/q\n\nspecified by array of sps (e.g., [[0,1,1,-1],[0,1,3,-1], [0,1,1,1],[0,1,3,1]])\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.check_major_valencespace-Tuple{String, Any, Any}","page":"IMSRG","title":"NuclearToolkit.check_major_valencespace","text":"check_major_valencespace(str::String,HFobj,v)\n\nFunction to check valence space and overwrite v and q fields of SingleParticleState The valencespace is specified by argument str (e.g. \"p-shell\") \n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.check_valence_space-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.check_valence_space","text":"check_valence_space(HFobj,valencespace)\n\ncheck validity of specified valence space\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.update_vsspace_chs!-Tuple{Any, Any, Any}","page":"IMSRG","title":"NuclearToolkit.update_vsspace_chs!","text":"update_vsspace_chs!(HFobj,valencespace,Chan2b)\n\noverwrite cc/vc/qc/vv/qv/qq channals\n\n\n\n\n\n","category":"method"},{"location":"IMSRG/#NuclearToolkit.write_vs_snt-NTuple{7, Any}","page":"IMSRG","title":"NuclearToolkit.write_vs_snt","text":"write_vs_snt(binfo,HFobj,IMSRGobj,Operators,effOps,Chan1b,Chan2bD,vspace)\n\nFunction to write out valence space effective interaction in snt (KSHELL/ShellModel.jl) format.\n\n\n\n\n\n","category":"method"},{"location":"contributing/#Contributing-to-NuclearToolkit.jl","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit.jl","text":"","category":"section"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"Thank you for considering contributing to this package.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"Feedbacks and contributions to NuclearToolkit.jl are very welcome. These can be:","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"bug report\nsubmitting a new function or a patch to the bug\ndocumentation issue\nfeature request\netc.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"For these contributions, it would be nice to let you know a basic policy (the workflow of code development and LICENSE, shown below) in this package. Note that the package has been developed by a single author (@SotaYoshida) so far, and thereby the followings are just the author's policy. Comments on the development policy itself are also welcome.","category":"page"},{"location":"contributing/#Workfklow-of-code-development","page":"Contributing to NuclearToolkit","title":"Workfklow of code development","text":"","category":"section"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"We use the GitHub to host the package, to track issues/pull requests.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"The document is built using Documenter.jl, which is a package for building documentation from docstrings and markdown files. It is automized to build and deploy the document using GitHub Actions.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"A typical workfklow of code development is the following:","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"clone or folk the repository and modify the code and/or document locally\npropose modifications through a pull request (PR) to develop branch\nif the PR passes the automated tests, it will be merged \nAt some point, we tag and release, which is done automatically by instructing the JuliaRegistrator bot to do so.","category":"page"},{"location":"contributing/#Automated-tests-on-GitHub-Actions","page":"Contributing to NuclearToolkit","title":"Automated tests on GitHub Actions","text":"","category":"section"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"We use GitHub Actions to run the test codes and to build/deploy the document. When some changes are submitted through a pull request, the test codes are run to check that the changes are not destructive.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"The test jobs are specified in yml files like .github/workflows/CI.yml and one can find the test code in test/ of the repository.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"The current test codes check","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"Generating a nucleon-nucleon potential, i.e., input for nuclear many-body methods\nHFMBPT results with the NN-potential\nIMSRG/VSIMSRG results the NN-potential\nshell-model results with the derived effective interaction by VS-IMSRG\nMPI and sampling stuffs are runnable","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"note: Note\nIf you submit a major change to the code, please consider to update the test codes matching to your modifications.","category":"page"},{"location":"contributing/#Reporting-bugs-by-opening-a-new-issue","page":"Contributing to NuclearToolkit","title":"Reporting bugs by opening a new issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"Thank you so much for considering to report bugs! When you report a bug in the code, please open an new issue from Here. Please make sure to include any information necessary for us to reproduce the errors. Thanks!","category":"page"},{"location":"contributing/#Propose-modifications-through-Pull-Requests-(PRs)","page":"Contributing to NuclearToolkit","title":"Propose modifications through Pull Requests (PRs)","text":"","category":"section"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"You can propose modifications you made on the package through pull requests.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"As stated above, please consider to make test codes matching to your modifications.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"Please make sure to submit your PR to develop branch. The 'main' branch will be protected by 'github branch protection'.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"As this package is currently being developed by a single author, branching rules such as git-flow and GitHub Flow have not been adopted. When we got contributors, the branch-rule will be set upon discussions.","category":"page"},{"location":"contributing/#Style-Guide-for-Julia","page":"Contributing to NuclearToolkit","title":"Style Guide for Julia","text":"","category":"section"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"If you are new to Julia language, Julia's Style Guide can be usefull to write your own codes. If the current code does not follow the style guide, we would be grateful if you could let us know.","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"It is recommended (not always necessarily) to add the so-called 'docstring' to the functions to explain what the function does and to generate document with Documenter.jl. An example is:","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"\"\"\"\n  Eval_EigenStates!(H::Hamiltonian,ψ::WaveFunction,n::Int64)\n\nFunction to calculate the lowest ``n`` wavefunctions and overwrite results to `ψ`.\n\n# Arguments\n- `H::Hamiltonian` the Hamiltonian of the system, see struct `Hamiltonian` for more details.\n- `ψ::WaveFunction` the wavefunction, see struct `WaveFunction` for more details.\n- `n::Int64` the number of states of interest.\n\"\"\"\nfunction Eval_EigenStates!(H::Hamiltonian,ψ::WaveFunction,n::Int64)\n    # write your nice codes here\n    \nend","category":"page"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"note: Note\nWhen you want to add a new API to the package, which can be called in Julia REPL, you need to export it at src/NuclearToolkit.jl.","category":"page"},{"location":"contributing/#LICENSE","page":"Contributing to NuclearToolkit","title":"LICENSE","text":"","category":"section"},{"location":"contributing/","page":"Contributing to NuclearToolkit","title":"Contributing to NuclearToolkit","text":"Any contribution from you will be under the MIT License, as well as the package itself. Feel free to contact to @SotaYoshida if that's a concern.","category":"page"},{"location":"fileformat/#snt-format","page":"FileFormat","title":"snt format","text":"","category":"section"},{"location":"fileformat/","page":"FileFormat","title":"FileFormat","text":"In NuclearToolkit.jl, input/output interactions are in the so-called snt format (or its binary form). The snt format is one used in widely-used shell-model code KSHELL. If you specify the option tbme_fmt=\"snt.bin\" for Chiral EFT interactions, the output becomes binary form.  The integers are in Int16 for a,b,c,d,J (single particle index and total-J of two-body matrix elements, TBMEs) and Int64 for others, and the floating point numbers for TBMEs are in Float32 (by default).","category":"page"},{"location":"fileformat/","page":"FileFormat","title":"FileFormat","text":"Here is an example of w.snt. The comments are not written in the outputs of NuclearToolkit.","category":"page"},{"location":"fileformat/","page":"FileFormat","title":"FileFormat","text":"! \"!\" denote comment line\n!\n! model space\n! proton-orbit, neutron-orbit, proton core, neutron core\n3 3 8 8\n! orbit n l j tz\n1 0 2 3 -1 ! 1 = p 0d_3/2\n2 0 2 5 -1 ! 2 = p 0d_5/2\n3 1 0 1 -1 ! 3 = p 1s_1/2\n4 0 2 3 1 ! 4 = n 0d_3/2\n5 0 2 5 1 ! 5 = n 0d_5/2\n6 1 0 1 1 ! 6 = n 1s_1/2\n! one-body interaction\n! number of lines, method1\n6 0\n! i j <i|V|j>\n1 1 1.64658\n2 2 -3.94780\n3 3 -3.16354\n4 4 1.64658\n5 5 -3.94780\n6 6 -3.16354\n! two-body interaction (TBME)\n! # of lines, method2 A mass dependence factor\n158 1 18 -0.30000\n! i j k l J <i,j| V | k,l>_J\n1 1 1 1 0 -2.18450\n1 1 1 1 2 -0.06650","category":"page"},{"location":"fileformat/","page":"FileFormat","title":"FileFormat","text":"For free space interactions, output of chiEFTint, they have V2n3n and Vpp terms in addition to the VNN term:","category":"page"},{"location":"fileformat/","page":"FileFormat","title":"FileFormat","text":"...\n! i j k l J <i,j| VNN | k,l>_J <i,j| V2n3n | k,l>_J <i,j| Vpp | k,l>_J\n  1    1    1    1     0     -6.4492081719      0.0000000000   -0.0000000000e+00\n  1    2    1    2     0     -1.9671496992      0.0000000000    5.0000000000e-01\n...","category":"page"},{"location":"HartreeFock/#Hartreefock","page":"HartreeFock","title":"Hartreefock","text":"","category":"section"},{"location":"HartreeFock/","page":"HartreeFock","title":"HartreeFock","text":"Files in src/hartreefock.jl for Hartree-Fock calculations.","category":"page"},{"location":"HartreeFock/","page":"HartreeFock","title":"HartreeFock","text":"def_struct.jl: define struct/mutable struct  \nhf_mbpt.jl: calculate HFMBPT energy correction\nio_input.jl: I/O stuffs and read input (snt file)\nmain.jl: main functions\noperator.jl: (scaler) operators and normal ordering","category":"page"},{"location":"HartreeFock/","page":"HartreeFock","title":"HartreeFock","text":"Modules = [NuclearToolkit]\nPages = [\"hartreefock.jl/def_struct.jl\",\n        \"hartreefock.jl/hf_mbpt.jl\",\n        \"hartreefock.jl/io_input.jl\",\n        \"hartreefock.jl/main.jl\",\n        \"hartreefock.jl/operator.jl\"]","category":"page"},{"location":"HartreeFock/#NuclearToolkit.Dict1b","page":"HartreeFock","title":"NuclearToolkit.Dict1b","text":"struct Dict1b \n\nFields\n\nsnt2ms::Dict{Int64,Int64} map from snt idx to modelspace(ms) idx\nms2snt::Dict{Int64,Int64} map from ms idx to snt idxdef_struct.jl\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.HamiltonianNormalOrdered","page":"HartreeFock","title":"NuclearToolkit.HamiltonianNormalOrdered","text":"struct HamiltonianNormalOrdered mainly called HFobj in the code.\n\nFields\n\nH::Operator Hamiltonian operator\nE0::Float64 NO0B of H\nEMP2::Float64 PT2 correction to E0\nEMP3::Float64 PT3 correction to E0\nCp::Matrix{Float64} eigenvectors of hp, used unitary trans. HO=>HF basis (proton part)\nCn::Matrix{Float64} eigenvectors of hn, unitary trans. HO=>HF basis (neutron part)\ne1b_p::Vector{Float64} eigenvalues of hp\ne1b_n::Vector{Float64} eigenvalues of hn\nmodelspace::ModelSpace\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.IMSRGobject","page":"HartreeFock","title":"NuclearToolkit.IMSRGobject","text":"mutable struct IMSRGobject\n\nFields\n\nH0::Operator Hamiltonian for starting point of BCH product\nH::Operator Hamiltonian H(s)\ns::Vector{Float} current s and ds\nsmax::Float maximum s\ndsmax::Float maximum ds\nmaxnormOmega::Float maximum ||Omega|| for spliting\nmagnusmethod::String \"\" or \"split\" => spliting method, \"NS\" or \"no-split\" => w/o spliting\neta::Operator generator of IMSRG flow (antihermite Operator)\nOmega::Operator generator of IMSRG flow (antihermite Operator) \neta_criterion::Float ||eta|| to check convergence\ndenominatorDelta::Float64 parameter for multi-major shell decoupling\nn_written_omega::Int # of written Omega by splitting to solve IMSRGflow\nNcomm::Vector{Int} # of commutator evaluated during IMSRG flow\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.ModelSpace","page":"HartreeFock","title":"NuclearToolkit.ModelSpace","text":"struct ModelSpace\n\nFields\n\np_sps::Vector{SingleParticleState} proton single particle states (only odd integer)\nn_sps::Vector{SingleParticleState} neutron single particle states\nsps::Vector{SingleParticleState} single particle states (odd number ones=>proton even=>neutron)\nocc_p::Matrix{Float64} matrix representing the occupation number of proton (needed for density matrix)\nocc_n::Matrix{Float64} matrix representing the occupation number of neutron\nholes::Vector{Vector{Int64}} idx list of holes\nparticles::Vector{Vector{Int64}} idx list of particles\nspaces::space_channel space_channel (mutable struct)\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.Operator","page":"HartreeFock","title":"NuclearToolkit.Operator","text":"struct Operator\n\nFields\n\nzerobody::Vector{Float64} zerobody part of the operator\nonebody::Vector{Matrix{Float64}} one-body matrix elements ([1]=>proton, [2]=>neutron)\ntwobody::Vector{Matrix{Float64}} two-body matrix elements, having array structure [ch]\nhermite::Bool whether it is hermitian operator or not\nantihermite::Bool antihermitian or not\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.PandyaObject","page":"HartreeFock","title":"NuclearToolkit.PandyaObject","text":"struct PandyaObject, used for Pandya transformation (especially in comm222ph_ss!)\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.SingleParticleState","page":"HartreeFock","title":"NuclearToolkit.SingleParticleState","text":"mutable struct SingleParticleState\n\nFields\n\nn::Int64 principal quantum number of the single particle state(sps)\nl::Int64 azimuthal quantum number of the sps\nj::Int64 angular momentum\ntz::Int64 z-component of isospin (doubled) tz=-1 => proton & tz=1 => neutron\nocc::Float64 occupation number (can be fractional) of the sps\nc::Bool indicating whether the single-particle state belongs to \"core\" or not \nv::Bool whether belongs to \"valence\" or not \nq::Bool whether belongs to \"q-space\" or not \n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.VdictCh","page":"HartreeFock","title":"NuclearToolkit.VdictCh","text":"struct VdictCh\n\nFields\n\nVch::Int64 two-body channel (specified by JPT)\nVdict::Dict{Int64,Int64} dict to get idx from ket, which is used in only vPandya function for HFMBPT\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.basedat","page":"HartreeFock","title":"NuclearToolkit.basedat","text":"struct basedat contains base infomation of the calculation\n\nFields\n\nnuc::nucleus information of target/core nucleus \nsntf::String filename/path to input interaction\nhw::Int64 hbar omega parameter used to define single particle states\nemax::Int64 emax truncation for the entire calculations\nref::String to specify ref=\"core\" or ref=\"nucl\"\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.chan1b","page":"HartreeFock","title":"NuclearToolkit.chan1b","text":"struct chan1b \n\nFields\n\nchs1b::Vector{Dict{Int64,Vector{Int64}}} dict of single particle states with non-zero contribution (having same l,j) [dict for proton sps, dict for neutron sps]\nchs1b_redundant::Vector{Dict{Int64,Vector{Int64}}} redundant version of chs1b (with i>j case)\nsnt2ms::Dict{Int64,Int64} map from snt idx to modelspace(ms) idx\nms2snt::Dict{Int64,Int64} map from ms idx to snt idx\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.chan2b","page":"HartreeFock","title":"NuclearToolkit.chan2b","text":"struct chan2b referred to as \"tbc\" (two-body channel) in some functions\n\nFields\n\nTz::Int64 total tz, -2(pp),0(pn),2(n)\nprty::Int64 parity\nJ::Int64 total J\nkets::Vector{Vector{Int64}} vector of ket (e.g. [1,1], [1,3],...)\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.chan2bD","page":"HartreeFock","title":"NuclearToolkit.chan2bD","text":"struct Chan2bD\n\nFields\n\nChan2b::Vector{chan2b} array of chan2b (ch=1,...,nchan)\ndict_ch_JPT::Dict{Vector{Int64},VdictCh} dict to get VdictCh by given key [J,prty,T]\ndict_ch_idx_from_ket::Vector{Dict{UInt64,NTuple{2,Int64}}} dict to get (ch,idx), having array structure [pnrank(=1/2/3)] and key structure [iket,jket,J].\ndict_idx_from_chket::Vector{Dict{Vector{Int64},Int64}} dict to get idx from ket, having array structure [ch]\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.dWS2n","page":"HartreeFock","title":"NuclearToolkit.dWS2n","text":"struct dWS2n, Wigner symbols used in PreCalcHOB\n\nFields\n\ndtri::Dict{Vector{Int64},Float64} dict for trinomial \ndcgm0::Dict{Int64,Float64} dict for special CG coefficients (l0l'0|L0)\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.dictSnt","page":"HartreeFock","title":"NuclearToolkit.dictSnt","text":"struct dictTBMEs contains dictionaries for TBME/monopole\n\nFields\n\ndictTBMEs::Vector{Dict{Vector{Int64},Float64}} one can get pp/pn/nn dict by dictTBMEs[pnrank] (pnrank=1,2,3)\ndictMonopole::Vector{Dict{Vector{Int64},valDictMonopole}} one can get monopole component of two-body interaction by dictMonopole[pnrank][key], key to be ket array like [1,1]\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.hfdata","page":"HartreeFock","title":"NuclearToolkit.hfdata","text":"struct hfdata, used to calculate multiple nucleus in a single runscript\n\nFields\n\nnuc::nucleus information of target/core nucleus\ndata::Vector{Vector{Float64}} will be experimental data from AME2020 (if available)\ndatatype::Vector{String} supposed to be [\"E\"] for now\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.nucleus","page":"HartreeFock","title":"NuclearToolkit.nucleus","text":"struct nucleus\n\nFields\n\nZ::Int64 proton number of the reference nucleus\nN::Int64 neutron number of the ref.\nA::Int64 mass number of the ref.\nel::String element (e.g., \"He\")\ncnuc::String string element nameA (e.g., \"He8\")\ncZ::Int64 proton number of core nucleus \ncN::Int64 neutron number of core\ncorenuc::String core nucleus (e.g., \"He4\")\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.single_util122","page":"HartreeFock","title":"NuclearToolkit.single_util122","text":"struct single_util122, used to make operation related commutator122 matrix manipulation\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.space_channel","page":"HartreeFock","title":"NuclearToolkit.space_channel","text":"mutable struct space_channel; dictionaries to get the two-body channels that have kets (specified by pp,ph, etc.)\n\nFields\n\npp::Dict{Int64,Vector{Int64}} particle-particle\nph::Dict{Int64,Vector{Int64}} particle-hole \nhh::Dict{Int64,Vector{Int64}} hole-hole\ncc::Dict{Int64,Vector{Int64}} core-core\nvc::Dict{Int64,Vector{Int64}} valence-core\nqc::Dict{Int64,Vector{Int64}} qspace-core\nvv::Dict{Int64,Vector{Int64}} valence-valence\nqv::Dict{Int64,Vector{Int64}} qspace-valence\nqq::Dict{Int64,Vector{Int64}} qspace-qspace\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock/#NuclearToolkit.HF_MBPT2-NTuple{8, Any}","page":"HartreeFock","title":"NuclearToolkit.HF_MBPT2","text":"HF_MBPT2(binfo,modelspace,fp,fn,e1b_p,e1b_n,Chan2b,Gamma)\n\nCalculate 2nd order correction to HF energy\n\nE^(2) = frac14sum_abij fracbarH^2_abij barH^2_ijabepsilon^ab_ij = frac14 sum_tildeatildebtildeitildejsum_msum_JJMM\nfrac^JbarH^2_tildeatildebtildeitildej ^JbarH^2_tildeitildejtildeatildebepsilon^ab_ij\n(j_a j_b m_a m_bJ M)\n(j_a j_b m_a m_bJ M)\n(j_i j_j m_i m_jJ M)\n(j_i j_j m_i m_jJ M)\n\n=\nfrac14 sum_tildeatildebtildeitildejsum_JJMM\nfrac^JbarH^2_tildeatildebtildeitildej ^JbarH^2_tildeitildejtildeatildebepsilon^ab_ij\ndelta_JJ delta_MM = frac14 sum_tildeatildebtildeitildejsum_J(2J+1)\nfrac^JbarH^2_tildeatildebtildeitildej ^JbarH^2_tildeitildejtildeatildebepsilon^ab_ij\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.HF_MBPT3-NTuple{9, Any}","page":"HartreeFock","title":"NuclearToolkit.HF_MBPT3","text":"HF_MBPT3(binfo,modelspace,e1b_p,e1b_n,Chan2b,dict_2b_ch,dWS,Gamma,to;io=stdout)\n\nCalculate 2nd order correction to HF energy\n\nE^(3)=\nfrac18 \nsum_tildeatildebtildectildeitildejtildek sum_J(2J+1)\nfrac\n^JbarH^2_tildeatildebtildeitildej \n^JbarH^2_tildeitildejtildectilded\n^JbarH^2_tildectildedtildeatildeb \n\nepsilon^tildeatildeb_tildeitildejepsilon^tildectilded_tildeitildej\n+\nfrac18 \nsum_tildeatildebtildeitildejtildektildel sum_J(2J+1)\nfrac\n^JbarH^2_tildeitildejtildeatildeb \n^JbarH^2_tildeatildebtildektildel\n^JbarH^2_tildektildeltildeitildej \n\nepsilon^tildeatildeb_tildeitildejepsilon^tildectilded_tildeitildej\n-sum_tildeatildebtildectildeitildejtildek sum_J(2J+1)\nfrac\n^JH^XC_tildeatildeitildejtildeb\n^JH^XC_tildejtildebtildektildec\n^JH^XC_tildektildectildeatildei\n\nepsilon^tildeatildeb epsilon_tildeitildej\nepsilon^tildeatildec epsilon_tildektildej\n\n\nRef. Many-Body Methods in Chemistry and Physics by Isaiah Shavitt and Rodney J. Bartlett (2009, Cambridge Molecular Science). More details can be found in e.g. Dr. thesis by A.Tichai (2017, TU Darmstadt).\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.vPandya-NTuple{13, Any}","page":"HartreeFock","title":"NuclearToolkit.vPandya","text":"vPandya(a,b,c,d,ja,jb,jc,jd,totJ,dict_2b_ch,d6j_lj,Gamma,keych,key6j,keyab;verbose=false)\n\nreturns generalized Pandya transformed matrix element:\n\ntildeV^J_ajib = -sum_J J \nbeginBmatrix \nj_a  j_j  J  j_i  j_d  J\nendBmatrix\nV^J_abij\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.cZN_from_corenuc-Tuple{Any, Any, String}","page":"HartreeFock","title":"NuclearToolkit.cZN_from_corenuc","text":"cZN_from_corenuc(rZ,rN,corenuc)\n\nget Z and N of the core nucleus\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.def_chan1b-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.def_chan1b","text":"def_chan1b(dim1b,sps,dicts1b)\n\ndefine Chan1b: dict. to get 1b-channels to be coupled to a given channel Chan1b = [ dictforprotonsps, dictforneutronsps] dicts1b Basically ToBeCoupled will be used, but redundant one is needed in some cases\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.def_chan2b-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.def_chan2b","text":"def_chan2b(binfo,dicts,sps)\n\ndefine two-body utils and returns them as Chan2bD struct \n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.def_nuc-Tuple{String, String, String}","page":"HartreeFock","title":"NuclearToolkit.def_nuc","text":"def_nuc(Z,N,ref,corenuc)\n\nconstructor of nucleus strict from given cnuc,ref,corenuc\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.def_nuc-Tuple{Vector{Int64}, String, String}","page":"HartreeFock","title":"NuclearToolkit.def_nuc","text":"def_nuc(nuc::Vector{Int},ref,corenuc)\n\nconstructor of nucleus strict from given Z,N,ref,corenuc\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.get_ZNref-Tuple{String, Int64, Int64, String}","page":"HartreeFock","title":"NuclearToolkit.get_ZNref","text":"get_ZNref(ref,Z,N,corenuc)\n\nget Z and N of the target reference\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.get_abcdarr_from_intkey!-Tuple{Any, Any}","page":"HartreeFock","title":"NuclearToolkit.get_abcdarr_from_intkey!","text":"get_abcdarr_from_intkey!(nkey,abcdarr;ofst=1000)\n\nA destructive function to get original array from integer array.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.make_sps_and_dict_isnt2ims-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.make_sps_and_dict_isnt2ims","text":"make_sps_and_dict_isnt2ims(p_sps,n_sps,lp)\n\nmake dicts1b, snt-idx(sntidx) = 1-lp (proton) & lp+1~lp+ln (neutron), modelspace-idx(msidx) = odd(1,3,...)-> proton, even(2,4,...) -> neutron\n\nreturns:\n\ndict_snt2ms: from sntidx to msidx \ndict_ms2snt: from msidx to sntidx\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.make_sps_from_pnsps-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.make_sps_from_pnsps","text":"make_sps_from_pnsps(p_sps,n_sps,Chan1b)\n\nconstruct sps from p_sps and n_sps\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.readsnt-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.readsnt","text":"readsnt(sntf,binfo,to)\n\nFunction to read snt file. Note that it is slightly different from readsnt() in ShellModel.jl.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.readsnt_bin-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.readsnt_bin","text":"readsnt(sntf,binfo,to)\n\nFunction to read snt.bin file.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.rm_comment-Tuple{Any}","page":"HartreeFock","title":"NuclearToolkit.rm_comment","text":"rm_comment(lines)\n\nremove fortran like comment from input (snt fmt) strings\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.store_1b2b-Tuple{Any, NuclearToolkit.Dict1b, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.store_1b2b","text":"store_1b2b(sps,dicts1b,dicts,binfo)\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.update_1b!-Tuple{Any, Any, NuclearToolkit.Operator}","page":"HartreeFock","title":"NuclearToolkit.update_1b!","text":"update_1b!(binfo,sps,Hamil)\n\nUpdate one-body(1b) part of Hamiltonian for different target nuclei\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.update_2b!-NTuple{6, Any}","page":"HartreeFock","title":"NuclearToolkit.update_2b!","text":"update_2b!(binfo,sps,Hamil,dictTBMEs,Chan2bD,dicts)\n\nUpdate two-body(2b) kinetic part for different target nuclei\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.ReorderHFSPS!-NTuple{7, Any}","page":"HartreeFock","title":"NuclearToolkit.ReorderHFSPS!","text":"ReorderHFSPS!(h_p,h_n,Cp,Cn,e1b_p,e1b_n,Chan1b)\n\n\"reorder\" HF single particle space. Since we diagonalize the h_p,h_n (istead of subblock mat), we need to specify the correspondance between ordering of sps and that of HFSPEs obtained by solving HF eigenvalue problem\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.add_ch_ket!-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.add_ch_ket!","text":"add_ch_ket!(ch,iket,tdict)\n\nadd ch & idx for kets in spaces::space_channel (pp/hh/etc.)\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.calc_Gamma!-NTuple{10, Any}","page":"HartreeFock","title":"NuclearToolkit.calc_Gamma!","text":"calc_Gamma!(Gamma,sps,Cp,Cn,V2,Chan2b,maxnpq)\n\nFunction to alculate Gamma (two-body HF interaction). Note: V3NO from genuine 3NF is supported for ver >= 0.4.0\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.def_holeparticle-NTuple{5, Any}","page":"HartreeFock","title":"NuclearToolkit.def_holeparticle","text":"def_holeparticle(Chan1b,occ_p,occ_n,p_sps,n_sps)\n\ndefine hole/particle space by occ_p, occ_n\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.def_sps-Tuple{Any}","page":"HartreeFock","title":"NuclearToolkit.def_sps","text":"def_sps(emax)\n\nFunction to define sps::Vector{SingleParticleState} from emax. \n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.getHNO-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Vector{NuclearToolkit.chan2b}, Any, Any, Any, Any, NuclearToolkit.Obj_3BME, Any}","page":"HartreeFock","title":"NuclearToolkit.getHNO","text":"getHNO(binfo,tHFdata,E0,p_sps,n_sps,occ_p,occ_n,h_p,h_n,e1b_p,e1b_n,Cp,Cn,V2,Chan1b,Chan2b::tChan2b,Gamma,maxnpq,dict_2b_ch,dWS,to) where{tChan2b <: Vector{chan2b}}\n\nobtain spherical HF solution and calc. MBPT correction (upto 2nd&3rd order) to g.s. energy\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.get_space_chs-Tuple{Any, Any}","page":"HartreeFock","title":"NuclearToolkit.get_space_chs","text":"get_space_chs(sps,Chan2b)\n\ndefine hole/particle single particle states. In this function, only the hh/pp/ph (needed for IMSRG) are defined, and other channels will be updated later for target normal ordering or VS-IMSRG flow.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.hf_iteration-NTuple{12, Any}","page":"HartreeFock","title":"NuclearToolkit.hf_iteration","text":"hf_iteration(binfo,tHFdata,sps,Hamil,dictTBMEs,Chan1b,Chan2bD,Gamma,maxnpq,dWS,to;itnum=100,verbose=false,HFtol=1.e-14,inttype=\"snt\")\n\nsolve HF equation\n\nThis function returns object with HamiltonianNormalOrdered (HNO) struct type, which contains...\n\nE0,EMP2,EMP3 HF energy and its MBPT corrections\nfp/fn::Matrix{Float64} one-body int.\nGamma:: Vector{Matrix{Float64}} two-body int.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.hf_main-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.hf_main","text":"hf_main(nucs,sntf,hw,emax;verbose=false,Operators=String[],is_show=false,doIMSRG=false,valencespace=[],corenuc=\"\",ref=\"nucl\")\n\nMain API to carry out HF/HFMBPT or IMSRG calculation from snt file\n\nArguments\n\nnucs::Vector{String} target nuclei\nsntf path to input interaction file\nhw hbar omega\nemax_calc emax for HF/IMSRG\n\nOptional Arguments\n\nverbose=false to see detailed stdout for HF\nOperators=String[] target observables other than Hamiltonian\nis_show=false to show TimerOutput log (summary of run time and memory allocation)\ndoIMSRG=false to carry out IMSRG/VSIMSRG calculation \nvalencespace=\"\" to spacify the valence space (e.g., \"sd-shell\" or [\"sd-shell\"], [[0,1,1,-1],[0,1,3,-1], [0,1,1,1],[0,1,3,1]]), if this is not empty, it tries to perform VS-IMSRG calculations\ncorenuc=\"\" core nucleus, example=> \"He4\"\nref=\"nucl\" to specify target reference state, \"core\" or \"nucl\" is supported.\nreturn_obj=false to return hfdata or imsrgdata object from this function\noupfn=\"\" to specify output file (writing stdout) name\nfn_params=\"optional_parameters.jl\" to specify the name of file to read optional parameters\ndebugmode=0 to specify debug mode (0: no debug, 1: debug, 2: debug with more details)\nHsample=false to specify whether to sample IMSRG omega and eta operators for emulators in hdf5 format \nrestart_from_files=String[] to specify the files to restart IMSRG flow from (e.g., [\"annomegavec_s20.h5\"]). If this has two elements, the first one is for IMSRG and the other one is for VS-IMSRG.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.hf_main_mem-Tuple{NuclearToolkit.ChiralEFTobject, Vararg{Any, 5}}","page":"HartreeFock","title":"NuclearToolkit.hf_main_mem","text":"hf_main_mem(chiEFTobj,nucs,dict_TM,dWS,to;verbose=false,Operators=String[],valencespace=\"\",corenuc=\"\",ref=\"core\")\n\n\"without I/O\" version of hf_main\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.ini_occ!-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.ini_occ!","text":"ini_occ!(pconf,occ_p,nconf,occ_n)\n\ninitialize occupation number matrices (occ_p&occ_n) by naive filling configurations pconf&nconf\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.naive_filling","page":"HartreeFock","title":"NuclearToolkit.naive_filling","text":"naive_filling(sps,n_target,emax,for_ref=false)\n\ncalculate naive filling configurations by given sps and proton/neutron number (n_target)\n\nFor some nuclei, especially for heavier ones, carrying out naive filling is ambiguous (e.g., neutron occupation of 22O can be both 0s1(2),0p1(2),0p3(4),0d5(6) and  0s1(2),0p1(2),0p3(4),1s1(2), 0d3(4)). In this function, \"naive filling\" means to try fill orbits with lower 2n+l and then \"lower\" j.\n\n\n\n\n\n","category":"function"},{"location":"HartreeFock/#NuclearToolkit.prepHFdata-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.prepHFdata","text":"prepHFdata(nucs,ref,datatype,corenuc)\n\nConstructor of an array of hfdata struct.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.printEHF-Tuple{Any}","page":"HartreeFock","title":"NuclearToolkit.printEHF","text":"printEHF(Es)\n\nprint HF energy and its break down Es=[E1b,E2bpp,E2bnn,E2bpn,E3b]\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.recalc_v!-Tuple{Any, Any}","page":"HartreeFock","title":"NuclearToolkit.recalc_v!","text":"recalc_v!(A,dicts)\n\nFunction to re-calculate two-body interaction from snt file for a different mass number. This is needed because in the readsnt/readsnt_bin function, the interaction part and the kinetic term  are stored separately to avoid multiple reads of the input file for calculation of multiple nuclei.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.update_FockMat!-NTuple{12, Any}","page":"HartreeFock","title":"NuclearToolkit.update_FockMat!","text":"update_FockMat!(\n    h_p,\n    p1b,\n    p_sps,\n    h_n,\n    n1b,\n    n_sps,\n    Vt_pp,\n    Vt_nn,\n    Vt_pn,\n    Vt_np,\n    Object_3NF,\n    V3tilde\n)\n\n\nFuncton updating Fock matrix. Since the F_ij\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.Calc_Expec-NTuple{9, Any}","page":"HartreeFock","title":"NuclearToolkit.Calc_Expec","text":"Calc_Expec(binfo,Chan1b,Chan2b,HFobj,Op_Rp2,dict_2b_ch,dWS,MatOp,to;hfmbptlevel=true,verbose=false)\n\nCalculate expectation value of Rp2 and its HFMBPT corrections.\n\nDetails about HFMBPT correction can be found in  Many-Body Methods in Chemistry and Physics by Isaiah Shavitt and Rodney J. Bartlett (2009, Cambridge Molecular Science)  or Appendix in T. Miyagi et al., Phys. Rev. C 105, 0143022 (2022).\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.CalculateTCM!-NTuple{5, Any}","page":"HartreeFock","title":"NuclearToolkit.CalculateTCM!","text":"TCM/A\n\nOne doesn't have to calc. two-body part here, since the necessary part is already calculated in Vpp.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.Calculate_RCM-NTuple{7, Any}","page":"HartreeFock","title":"NuclearToolkit.Calculate_RCM","text":"Calculate_RCM(binfo,Chan1b,Chan2b,sps,Op_Rp2,dWS,to;non0_cm=true,non0_ij=true)\n\ncalculate R_CM term\n\nNote that rirj term is also included here to avoid redundancy.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.Calculate_Rp-NTuple{9, Any}","page":"HartreeFock","title":"NuclearToolkit.Calculate_Rp","text":"Calculate_Rp(binfo,Chan1b,Chan2b,HFobj,Op_Rp2,dWS,dict_2b_ch,to;hfmbptlevel=true)\n\nTo calculate squared point proton radius and its MBPT correction. The squared point proton radius is related to the charge radius as follows\n\nR^2_ch = R^2_p + langle r^2_p rangle + fracNZ langle r^2_n rangle + frac34m^2_p c^4 \n+ langle r^2 rangle_SO\n\nwhere langle r^2_p rangle = 0769 mathrmfm^2, langle r^2_n rangle = -0116 mathrmfm^2, frac34m^2_p c^4 =0033mathrmfm^2 is the so-called Darwin-Foldy term, and the last term is Spin-Orbit correction term.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.Calculate_SOterm-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.Calculate_SOterm","text":"Calculate_SOterm(binfo,Chan1b,HFobj,Op_Rp2)\n\nCalculate Spin-Orbit Correction term for Rp2. We are using \"simple expression for the correction to the mean-square charge radius due to the spin-orbit term\" in the reference below:\n\nlangle r^2 rangle_SO =-frac1Zsum_i fracmu_iM^2 (kappa_i+1)\n\nwhere mu_p = 2793 mu_N, mu_n = 1913mu_N, and kappa = ell (mathrmfor  j=ell-12) -(ell+1) (mathrmfor j=ell+12)\n\nRef: A.Ong, J.C.Berengut, and V.V.Flambaum, Phys. Rev. C 82, 014320 (2010).\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.Calculate_intR2p-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.Calculate_intR2p","text":"Calculate_intR2p(binfo,Chan1b,HFobj,Op_Rp2)\n\ncalculate a part of squared point proton radius R2p. Note that this function overwrites the onebody part of given Op_Rp2.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.InitOp-Tuple{Any, Any}","page":"HartreeFock","title":"NuclearToolkit.InitOp","text":"InitOp(Chan1b,Chan2b)\n\ninitialize scaler Operator, note that hermite is true as default\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.aOp!-Tuple{NuclearToolkit.Operator, Float64}","page":"HartreeFock","title":"NuclearToolkit.aOp!","text":"aOp!(Op::Operator,a::Float64)\n\nfunction to multiply scaler to an operator.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.aOp1_p_bOp2!-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64}","page":"HartreeFock","title":"NuclearToolkit.aOp1_p_bOp2!","text":"aOp1_p_bOp2!(Op1::Operator,Op2::Operator,a::Float64,b::Float64)\n\nfunction to overwrite Op2 by a*Op1 + b*Op2\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.aOp1_p_bOp2-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64}","page":"HartreeFock","title":"NuclearToolkit.aOp1_p_bOp2","text":"aOp1_p_bOp2(Op1::Operator,Op2::Operator,a,b)\n\nfunction to return new Operator = aOp1 + bOp2\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.aOp1_p_bOp2_Op3!-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64, Float64}","page":"HartreeFock","title":"NuclearToolkit.aOp1_p_bOp2_Op3!","text":"aOp1_p_bOp2_Op3!(Op1::Operator,Op2::Operator,Op3::Operator,a,b,c)\n\nfunction to overwrite Op3 by c*Op3 + a*Op1 + b*Op2\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.calc_single_r1r2-NTuple{7, Any}","page":"HartreeFock","title":"NuclearToolkit.calc_single_r1r2","text":"calc_single_r1r2(bra,ket,sps,J,dWS,b2,to)\n\nCalc r_1 cdot r_2 for a given 2b-channel.\n\nbra: <ab| a&b: s.p.s. (n,l,j,tz)\nket: |cd> c&d: s.p.s. (n,l,j,tz)\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.difA_RCM-Tuple{NuclearToolkit.Operator, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.difA_RCM","text":"difA_RCM(Op::Operator,Aold,Anew)\n\nFunction to redefine RCM. Note that non0_ij for Calculate_RCM assumed to be false.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.eval_rch_hfmbpt-NTuple{8, Any}","page":"HartreeFock","title":"NuclearToolkit.eval_rch_hfmbpt","text":"eval_rch_hfmbpt(binfo,Chan1b,Chan2bD,HFobj,Op_Rp2,dWS,to)\n\nfunction to evaluate charge radii with HFMBPT\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.eval_rch_imsrg-NTuple{12, Any}","page":"HartreeFock","title":"NuclearToolkit.eval_rch_imsrg","text":"eval_rch_imsrg(binfo,Chan1b,Chan2bD,HFobj,IMSRGobj,PandyaObj,dWS,dictMono,to)\n\nevaluate charge radii with IMSRG.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.getNormalOrderedO-NTuple{5, Any}","page":"HartreeFock","title":"NuclearToolkit.getNormalOrderedO","text":"getNormalOrderedO(HFobj,targetOp,Chan1b,Chan2bD,to;verbose=false,undo=false,OpeqH=false,firstNO=false)\n\nNormalOrdering for a target Operator. For now, it only supports scaler operators.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock/#NuclearToolkit.show_Hamil_norm-Tuple{NuclearToolkit.Operator}","page":"HartreeFock","title":"NuclearToolkit.show_Hamil_norm","text":"show_Hamil_norm(Op::Operator;tol=1.e-6,normtype=\"fro\")\n\nFunction to show 1b/2b norm of a given Operator. It may be usuful for debug.\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#ShellModel","page":"ShellModel","title":"ShellModel","text":"","category":"section"},{"location":"ShellModel/","page":"ShellModel","title":"ShellModel","text":"Functions for shell-model calculations","category":"page"},{"location":"ShellModel/","page":"ShellModel","title":"ShellModel","text":"shellmodel_main.jl: contains main and util functions \nlanczos_methods.jl: Lanczos methods\ntransit.jl: EM transitions\ninputintsnt.jl: I/O stuffs\neigenvector_continuation.jl: eigenvector continuation to sample and construct shell-model wavefunctions\nKSHELL.jl: dealing with KSHELL outputs\nbetadecay.jl: evaluate beta-decay properties using KSHELL log/summary","category":"page"},{"location":"ShellModel/","page":"ShellModel","title":"ShellModel","text":"Modules = [NuclearToolkit]\nPages = [\"ShellModel/shellmodel_main.jl\",\n         \"ShellModel/lanczos_methods.jl\",\n         \"ShellModel/transit.jl\",\n         \"ShellModel/input_int_snt.jl\",\n         \"ShellModel/eigenvector_continuation.jl\",\n         \"ShellModel/KSHELL.jl\",\n         \"ShellModel/betadecay.jl\"]","category":"page"},{"location":"ShellModel/#NuclearToolkit.T1info","page":"ShellModel","title":"NuclearToolkit.T1info","text":"Struct to store 2b-jumps (T=1).\n\nThis includes the following information: f::Int64 the final index f for a given index i/ coef::Float64 the coefficient of the 2b-jump.\n\n\n\n\n\n","category":"type"},{"location":"ShellModel/#NuclearToolkit.all_perm!-Tuple{Int64, Int64, Array{Vector{Bool}}}","page":"ShellModel","title":"NuclearToolkit.all_perm!","text":"all_perm!(ln::Int64,num_valence::Int64,occs::Array{Array{Bool,1}})\n\nmake all possible permutation of 'bits'\n\nExample: If 2 protons and 1 neutron are in the 0p-shell space, valence orbits(0p1/2,0p3/2) => -1/2, 1/2, -3/2, -1/2, 1/2, 3/2\n\nconfigurations are represented like:\n\nproton: 000011, 000101, ..., 110000\n\nneutron: 000001, 000010, ..., 100000\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.check_jocc_truncation","page":"ShellModel","title":"NuclearToolkit.check_jocc_truncation","text":"Function to check if the specified configuration tocc_j is valid within a given truncation scheme.\n\n\n\n\n\n","category":"function"},{"location":"ShellModel/#NuclearToolkit.check_pnpair_truncation","page":"ShellModel","title":"NuclearToolkit.check_pnpair_truncation","text":"Function to check occupations in proton and neutron are only in time-reversal pairs.\n\n\n\n\n\n","category":"function"},{"location":"ShellModel/#NuclearToolkit.construct_msps-Tuple{Any, Any}","page":"ShellModel","title":"NuclearToolkit.construct_msps","text":"constructmsps(psps,n_sps)\n\nFunction to define the single particle states specified by [n,l,j,tz,mz,p(n)idx]. The last elements pidx and nidx to represent original index of p_sps/n_sps, which is specified by [n,l,j,tz]`.\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.main_sm-NTuple{4, Any}","page":"ShellModel","title":"NuclearToolkit.main_sm","text":"mainsm(sntf,targetnuc,numev,targetJ;         savewav=false,q=1,isblock=false,isshow=false,numhistory=3,lm=300,ls=20,tol=1.e-8,         inwf=\"\",mdimmode=false,calcmoment=false, visualize_occ=false, gfactors=[1.0,0.0,5.586,-3.826],effcharge=[1.5,0.5])\n\nDigonalize the model-space Hamiltonian \n\nArguments:\n\nsntf:       path to input interaction file (.snt fmt)\ntarget_nuc: target nucleus\nnum_ev:     number of eigenstates to be evaluated\ntarget_J:   target total J (specified by e.g. [0]). Set to [] if you want lowest states with any J.   Note that J should be doubled (J=0=>[0], J=1/2=>[1], J=1=>[2],...) \n\nOptional arguments:\n\nq=1              block size for Block-Lanczos methods \nis_block=false   whether or not to use Block algorithm \nsave_wav=false   whether or not to save wavefunction file \nis_show = true   to show elapsed time & allocations \nlm = 100         number of Lanczos vectors to store \nls = 20          number of vectors to be used for Thick-Restart \ntol= 1.e-8       tolerance for convergence check in the Lanczos method \nin_wf=\"\"      path to initial w.f. (for preprocessing) \nmdimmode=false   true => calculate only the M-scheme dimension\ncalc_moment=false  true => calculate mu&Q moments \ncalc_entropy=false true => calculate entropy, which is not optimized yet.\nvisualize_occ=false true => visualize all configurations to be considered\ngfactors=[1.0,0.0,5.586,-3.826] angular momentum and spin g-factors \neffcgarge=[1.5,0.5] effective charges \ntruncation_scheme==\"\" option to specify a truncation scheme, \"jocc\" and \"pn-pair\" is supported and you can use multiple schemes by separating them with camma like \"jocc,pn-pair\".\ntruncated_jocc=Dict{String,Vector{Int64}}() option to specify the truncation scheme for each orbit, e.g. Dict(\"p0p1\"=>[1],\"n0p3\"=>[2,3]) means that the occupation number for proton 0p1 is truncated upto 1, and for neutron 0p3 min=2 and max=3\"\ndebugmode= \"\" option to specify debug mode. Lanczos/BlockLanczos are supported\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.occ-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Int64}, Int64, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Int64}, Int64, Int64}","page":"ShellModel","title":"NuclearToolkit.occ","text":"occ(p_sps::Array{Array{Int64,1}},msps_p::Array{Array{Int64,1}},mzp::Array{Int64,1},num_vp::Int64,\n    n_sps::Array{Array{Int64,1}},msps_n::Array{Array{Int64,1}},mzn::Array{Int64,1},num_vn::Int64,Mtot::Int64;pnpair_truncated=false)\n\nprepare bit representations of proton/neutron Slater determinants => pbits/nbits\n\njoccp, joccn: corresponding occupation numbers for a \"j\" state,   which is used for one-body operation and OBTDs.  \n\nMps/Mns: total M for proton/neutron \"blocks\"\n\nFor 6Li in the p shell and M=0, Mps = [-3,-1,1,3] & Mns = [3,1,-1,-3]   blocks => [ (Mp,Mn)=(-3,3),(Mp,Mn)=(-1,1),...]  \n\ntdims: array of cumulative number of M-scheme dimensions for \"blocks\"  \n\ntdims =[ # of possible configurations of (-3,3),            # of possible configurations of (-1,1),...]  \n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.prep_Hamil_T1-Tuple{Array{Vector{Int64}}, Array{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Any, Any, Vector{Vector{Vector{Int64}}}, Array{Vector{Float64}}}","page":"ShellModel","title":"NuclearToolkit.prep_Hamil_T1","text":"function prep_Hamil_T1(p_sps::Array{Array{Int64,1}},n_sps::Array{Array{Int64,1}},\n            msps_p::Array{Array{Int64,1},1},msps_n::Array{Array{Int64,1},1},\n            labels::Array{Array{Array{Int64,1},1},1},TBMEs::Array{Array{Float64,1}})\n\nFirst, this makes bit representations of T=1 (proton-proton&neutron-neutron) interactions for each {m_z}.\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.prep_Hamil_pn","page":"ShellModel","title":"NuclearToolkit.prep_Hamil_pn","text":"prep_Hamil_pn(p_sps::Array{Array{Int64,1}},n_sps::Array{Array{Int64,1}},\n       msps_p::Array{Array{Int64,1},1},msps_n::Array{Array{Int64,1},1},\n       labels::Array{Array{Int64,1}},TBMEs::Array{Float64,1},zeroME=false)\n\nmake bit representation of T=0 (proton-neutron) interactions for each {m_z}\n\n\n\n\n\n","category":"function"},{"location":"ShellModel/#NuclearToolkit.readsmsnt-Tuple{Any, Any}","page":"ShellModel","title":"NuclearToolkit.readsmsnt","text":"readsmsnt(sntf,Anum)\n\nTo read interaction file in \".snt\" format.\n\nsntf: path to the interaction file\nAnum: mass number (used for \"scaling\" of TBMEs)\n\nnote: Note\nThe current version supports only \"properly ordered\",like a leq bc leq da leq c for V(abcdJ), snt file.\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.visualize_configurations-NTuple{5, Any}","page":"ShellModel","title":"NuclearToolkit.visualize_configurations","text":"visualize all configurations in a given model-space\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.TRBL-NTuple{34, Any}","page":"ShellModel","title":"NuclearToolkit.TRBL","text":"Thick-Restart Block Lanczos method\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.init_ho_by_mass","page":"ShellModel","title":"NuclearToolkit.init_ho_by_mass","text":"Set HO parameter by an empirical formula.\n\nThe default choice is 41A^(-1/3) MeV. For sd-shell nuclei (16<=A<=40), we use 45A^(-1/3)-25A^(-2/3) MeV by J. Blomqvist and A. Molinari, Nucl. Phys. A106, 545 (1968).\n\n\n\n\n\n","category":"function"},{"location":"ShellModel/#NuclearToolkit.transit_main-NTuple{5, Any}","page":"ShellModel","title":"NuclearToolkit.transit_main","text":"transit_main(sntf,target_nuc,jl2,jr2,in_wfs;num_ev_l=100,num_ev_r=100,q=1,is_block=false,is_show=true,calc_EM=true,gfactors=[1.0,0.0,5.586,-3.826],eff_charge=[1.5,0.5])\n\nFunction tocalculate the M1&E2 transitions from two given wavefunctions\n\nArguments\n\nsntf:path to the interaction file\ntarget_nuc:target nucleus in string e.g., \"Si28\"\njl2:J*2 for the left w.f.\njr2:J*2 for the right w.f.\nin_wfs:[\"path to left wf\",\"path to right wf\"]\n\nOptional arguments\n\nnum_ev_l=100:upper limit of the number of eigenvectors for the left w.f.\nnum_ev_r=100:upper limit of the number of eigenvectors for the right w.f.\nis_show=true:to display the TimerOutput\ngfactors=[1.0,0.0,5.586,-3.826]:g factors [glp,gln,gsp,gsn]\neff_charge=[1.5,0.5]:effective charges [ep,en]\n\nOptional arguments (not used, but for future developments)\n\nq=1:block size\nis_block=false:to use Block algorithm\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.solveEC-Tuple{Any, Any, Any}","page":"ShellModel","title":"NuclearToolkit.solveEC","text":"solveEC(Hs,target_nuc,tJNs;\n        write_appwav=false,verbose=false,calc_moment=true,wpath=\"./\",is_show=false,\n        gfactors = [1.0,0.0,5.586,-3.826],effcharge=[1.5,0.5],exact_logf=\"\")\n\nTo solve EC (generalized eigenvalue problem) to approximate the eigenpairs for a given interaction.\n\nH vecv = lambda N vecv\n\nTransition densities and overlap matrix for H and N are read from \"tdmat/\" directory (To be changed to more flexible)\n\nArguments:\n\nHs:array of paths to interaction files (.snt fmt)\ntarget_nuc: target nucleus\ntJNs:array of target total J (doubled) and number of eigenstates to be evaluated   e.g., [ [0,5], [2,5] ], when you want five lowest J=0 and J=1 states.\n\nOptional arguments:\n\nwrite_appwav=false:write out the approximate wavefunction\nverbose=false:to print (stdout) approx. energies for each interaction\ncalc_moment=true: to calculate mu&Q moments\nwpath=\"./\": path to sample eigenvectors to construct approx. w.f.\nis_show=false: to show TimerOutput\ngfactors=[1.0,0.0,5.586,-3.826]: g-factors to evaluate moments\neffcharge=[1.5,0.5]:effective charges to evaluate moments\n\nOptional arguments for author's own purpose\n\nexact_logf=\"\":path to logfile for E(EC) vs E(Exact) plot\n\nnote: Note\nAll the effective interactions must be in \"the same order\" and must be consistent with interaction file from which the transition density matrices were made.\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.read_kshell_summary-Tuple{Vector{String}}","page":"ShellModel","title":"NuclearToolkit.read_kshell_summary","text":"read_kshell_summary(fns::Vector{String};targetJpi=\"\",nuc=\"\")\n\nReading KSHELL summary file from specified paths, fns. In some beta-decay studies, multiple candidates for parent g.s. will be considered. In that case, please specify optional argument targetJpi e.g., targetJpi=\"Si36\", otherwise the state havbing the lowest energy in summary file(s) will be regarded as the parent ground state. Example:\n\nEnergy levels\n\nN    J prty N_Jp    T     E(MeV)  Ex(MeV)  log-file\n\n1     0 +     1     6   -319.906    0.000  log_Ar48_SDPFSDG_j0p.txt \n\nnote: Note\nJ is doubled in old versions of KSHELL (kshell_ui.py).\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.Ecoulomb_SM-Tuple{Any, Any}","page":"ShellModel","title":"NuclearToolkit.Ecoulomb_SM","text":"Ecoulomb_SM(Z,N)\n\nAdditional Coulomb energy (MeV)\n\nE_C(ZN) = 07 fracZ(Z-1) -076 Z(Z-1)^23R_c \nR_c = e^15A A^13 left( 0946 -0573 left( frac2TA right)^2  right) \nT = Z-N2 \n\nused in references.\n\nS.Yoshida et al., Phys. Rev. C 97, 054321 (2018).\nJ. Duflo and A. P. Zuker, Phys. Rev. C 52, R23 (1995).\nE. Caurier et al., Phys. Rev. C 59, 2033 (1999).\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.Fermi_function-Tuple{Any, Any, Any}","page":"ShellModel","title":"NuclearToolkit.Fermi_function","text":"Fermi_function(Z,We,R)\n\nF(ZW) = 4 (2p_e R)^-2(1-gamma_1) exp left( pi y fracGamma(gamma_1 + iy)^2 Gamma(2gamma_1 + 1)^2  right) \ngamma_k = sqrtk^2 - alpha^2 Z^2 \ny = alpha Z W  p_e\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.Fermi_integral","page":"ShellModel","title":"NuclearToolkit.Fermi_integral","text":"Fermi_integral(Qval,Ex,pZ,A,nmesh=40)\n\nFermi integrals are evaluated with Eqs. in Chapter 5 of \"Weak Interactions and Nuclear Beta Decay\" by H. F. Schopper.]\n\nf_0 = int^W_0_1 F(ZW) sqrtW^2-1 W(W_0-W)^2 dW \nW_0 = Q(beta^-) + 1 - E_mathrmex\n\nNote that Ws are in natural unit, divided by m_ec^2.\n\n\n\n\n\n","category":"function"},{"location":"ShellModel/#NuclearToolkit.ME_FF_func!-NTuple{7, Any}","page":"ShellModel","title":"NuclearToolkit.ME_FF_func!","text":"ME_FF_func!(chan,qfactors,C_J,Mred,lambda_Ce,mass_n_nu,dict)\n\nFunction to calc FF matrix elements. Since M0rs,M1r,M1rs,M2rs (M0sp,M1p) are evaluated in fm (1/fm) in KSHELL, it is needed to multiply 1/lambdaCe (lambdaCe) to get transition matrix element in natural unit.\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.eval_betadecay_from_kshell_log-Tuple{Vector{String}, Vector{String}, Vector{String}, Vector{String}, String}","page":"ShellModel","title":"NuclearToolkit.eval_betadecay_from_kshell_log","text":"eval_betadecay_from_kshell_log(fns_sum_parent::Vector{String},fns_sum_daughter::Vector{String},fns_GT::Vector{String},fns_FF::Vector{String},parentJpi::String;pnuc=\"\",dnuc=\"\",verbose=false)\n\nArguments\n\nfns_sum_parent::Vector{String} vector of paths to KSHELL-summary files for the parent nucleus\nfns_sum_daughter::Vector{String} vector of paths to KSHELL-summary files for the daughter nucleus\nfns_GT::Vector{String} vector of paths to KSHELL-log files for Gamow-Teller transitions.\nfns_FF::Vector{String} vector of paths to KSHELL-log files for First-Forbidden transitions.\n\nOptional Arguments\n\npnuc::String to specify the parent nuclei explicitly\ndnuc::String to specify the daughter nuclei explicitly\nverbose::Bool option to show GT/FF transitions for each state\n\n\n\n\n\n","category":"method"},{"location":"ShellModel/#NuclearToolkit.read_bgtstrength_file!-Tuple{String, NuclearToolkit.quenching_factors, NuclearToolkit.kshell_nuc, NuclearToolkit.kshell_nuc, Any, Any}","page":"ShellModel","title":"NuclearToolkit.read_bgtstrength_file!","text":"\n\n\n\n","category":"method"},{"location":"#NuclearToolkit","page":"Home","title":"NuclearToolkit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia Toolkit for nuclear structure calculations","category":"page"},{"location":"#Installation-and-example","page":"Home","title":"Installation and example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First, prepare Julia environment v >= 1.7.0.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Second, add the package in Pkg mode","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]add NuclearToolkit","category":"page"},{"location":"","page":"Home","title":"Home","text":"Too see how to run the code, it is strongly recommended to clone the repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sample script sample_script.jl in the repository performs","category":"page"},{"location":"","page":"Home","title":"Home","text":"calculating NN potential by Chiral EFT\nHFMBPT(3) and IMSRG/VS-IMSRG(2) calculation\nshell-model calculations with the effective interaction derived by VS-IMSRG","category":"page"},{"location":"","page":"Home","title":"Home","text":"in sequence. One can try as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -t 8 sample_script.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can specify target nuclei, emax, hw, etc., by editting the script and optional_parameters.jl, if necessary.","category":"page"},{"location":"#Package-features-and-building-blocks","page":"Home","title":"Package features and building blocks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NuclearToolkit.jl provides a self-contained set of nuclear structure calculation codes covering from nuclear force to many-body methods (HF/HFMBPT, IM-SRG/VS-IMSRG, shell model, etc.).","category":"page"},{"location":"","page":"Home","title":"Home","text":"One of the main motivations for the author to develop NuclearToolkit.jl is, of course, for their own research purposes, and another one is for educational purpose. A single nuclear structure calculation code often contains tens of thousands to nearly 100,000 lines. In the author's personal opinion, it would be too difficult for students (especially in undergraduate or two-year master course) to understand the technical details of the latest nuclear many-body methods while reading the enormous length of existing codes in the community.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The author thought the Julia language can be a game changer to this situation with its high readbility, portabillity, and performance. Since all the source code in NuclearToolkit.jl is a pure Julia implementation, there is no more need to prepare different Makefiles for different environments, worry about library dependencies, homemade Python script to run the Fortran/C++ codes. The code can be easily executed on either a laptop or a supercomputer. While NuclearToolkit covers a wide range of methods, the overall code length is still in a few tens of thousands, including \"docstring\" to generate the document.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ChiEFTint: NN interaction from Chiral EFT ~ 9,000 lines.\nNN interactions such as EM (Entem & Machleidt) N3L0, EMN (Entem, Machleidt, Nosyc) N4LO, NNLOsat\nDensity-Dependent NN from 3NF (The author prefers to call it \"2n3n\" to distinguish with genuine 3NF)\nvalence chiral EFT potential upto LO (no longer maintained)\nHartreefock: Hartree-Fock (HF) and HF Many-Body Perturbation Theory (HFMBPT)  ~ 3,500 lines.\nEnergy (up to 3rd order)\nScaler operator (up to 2nd order)\nIMSRG: In-medium Similarity Renormalization Group (IMSRG)  ~ 2,800 lines.\nIMSRG(2) calc. for ground state energy\nconsistent IMSRG(2) flow of (scaler) operator using Magnus formulation\nValence-space IMSRG (VS-IMSRG)\nderive effective interaction for shell-model calculations\nconsistent VSIMSRG flow to get effective operators \nShellModel.jl ~ 6,500 lines. This was originally developed as an independent package.\nshell model calculations on a single major shell\nconstruct approximate wavefunctions with eigenvector continuation ","category":"page"},{"location":"#Optional-parameters","page":"Home","title":"Optional parameters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For some parameters, the default values are used unless the user specifies those in the file, optional_parameters.jl. See the Optional parameters page for more details.","category":"page"},{"location":"#Issues/Pull-requests","page":"Home","title":"Issues/Pull requests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NuclearToolkit.jl is designed to be an open-source software and to guarantee reproducibility and transparancy of the future works. Making issues and pull requests are fully welcome.","category":"page"}]
}
