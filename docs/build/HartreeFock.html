<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HartreeFock · NuclearToolkit.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://SotaYoshida.github.io/NuclearToolkit.jl/HartreeFock.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="NuclearToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">NuclearToolkit.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="ChiEFTint.html">ChiEFTint</a></li><li class="is-active"><a class="tocitem" href="HartreeFock.html">HartreeFock</a></li><li><a class="tocitem" href="IMSRG.html">IMSRG</a></li><li><a class="tocitem" href="ShellModel.html">ShellModel</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="HartreeFock.html">HartreeFock</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="HartreeFock.html">HartreeFock</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/master/docs/src/HartreeFock.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hartreefock"><a class="docs-heading-anchor" href="#Hartreefock">Hartreefock</a><a id="Hartreefock-1"></a><a class="docs-heading-anchor-permalink" href="#Hartreefock" title="Permalink"></a></h1><p>Functions for Hartree-Fock calculations.</p><ul><li><a href="../../src/hartreefock.jl/def_struct.jl">def_struct.jl</a>: define struct/mutable struct  </li><li><a href="../../src/hartreefock.jl/hf_mbpt.jl">hf_mbpt.jl</a>: calculate HFMBPT energy correction</li><li><a href="../../src/hartreefock.jl/io_input.jl">io_input.jl</a>: I/O stuffs and read input (snt file)</li><li><a href="../../src/hartreefock.jl/main.jl">main.jl</a>: main functions</li><li><a href="../../src/hartreefock.jl/operator.jl">operator.jl</a>: (scaler) operators and normal ordering</li></ul><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Chan2bD" href="#NuclearToolkit.Chan2bD"><code>NuclearToolkit.Chan2bD</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>chan2bD</code></p><p><strong>Fields</strong></p><ul><li><code>Chan2b::Vector{chan2b}</code> array of chan2b (ch=1,...,nchan)</li><li><code>dict_ch_JPT::Dict{Vector{Int64},VdictCh}</code> dict to get VdictCh by given key <code>[J,prty,T]</code></li><li><code>dict_ch_idx_from_ket::Vector{Vector{Dict{Vector{Int64},Vector{Vector{Int64}}}}}</code> dict to get [ch,idx], having array structure [pnrank(=1/2/3)][J+1], <code>key</code>=ket</li><li><code>dict_idx_from_chket::Vector{Dict{Vector{Int64},Int64}}</code> dict to get idx from ket, having array structure [ch]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Dict1b" href="#NuclearToolkit.Dict1b"><code>NuclearToolkit.Dict1b</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>Dict1b</code> </p><p><strong>Fields</strong></p><ul><li><code>snt2ms::Dict{Int64,Int64}</code> map from snt idx to modelspace(ms) idx</li><li><code>ms2snt::Dict{Int64,Int64}</code> map from ms idx to snt idxdef_struct.jl</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.HamiltonianNormalOrdered" href="#NuclearToolkit.HamiltonianNormalOrdered"><code>NuclearToolkit.HamiltonianNormalOrdered</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>HamiltonianNormalOrdered</code></p><p><strong>Fields</strong></p><ul><li><code>H::Operator</code> Hamiltonian operator</li><li><code>E0::Float64</code> NO0B of H</li><li><code>EMP2::Float64</code> PT2 correction to E0</li><li><code>EMP3::Float64</code> PT3 correction to E0</li><li><code>Cp::Matrix{Float64}</code> eigenvectors of hp, used unitary trans. HO=&gt;HF basis (proton part)</li><li><code>Cn::Matrix{Float64}</code> eigenvectors of hn, unitary trans. HO=&gt;HF basis (neutron part)</li><li><code>e1b_p::Vector{Float64}</code> eigenvalues of hp</li><li><code>e1b_n::Vector{Float64}</code> eigenvalues of hn</li><li><code>modelspace::ModelSpace</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L256-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.HarmonicOscillatorBrackets" href="#NuclearToolkit.HarmonicOscillatorBrackets"><code>NuclearToolkit.HarmonicOscillatorBrackets</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>HarmonicOscillatorBrackets</code></p><p>A hierarchical array of dictionaries reduces readability, but on the other hand a few hierarchical structures. It may reduce the time taken to traverse the elements...</p><p><strong>Fields</strong></p><ul><li><code>dict::Vector{Vector{Dict{Vector{Int64},Float64}}}</code> dictionary for HOB [L][e2] #e2=2n+l+2N+L=2n1+l1+2n2+l2</li><li><code>key::Vector{Int64}</code> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L325-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.IMSRGobject" href="#NuclearToolkit.IMSRGobject"><code>NuclearToolkit.IMSRGobject</code></a> — <span class="docstring-category">Type</span></header><section><div><p>mutable struct <code>IMSRGobject</code></p><p><strong>Fields</strong></p><ul><li><code>H0::Operator</code> Hamiltonian for starting point of BCH product</li><li><code>H::Operator</code> Hamiltonian <span>$H(s)$</span></li><li><code>s::Vector{Float}</code> current <span>$s$</span> and <span>$ds$</span></li><li><code>smax::Float</code> maximum <span>$s$</span></li><li><code>dsmax::Float</code> maximum <span>$ds$</span></li><li><code>maxnormOmega::Float</code> maximum ||Omega||</li><li><code>eta::Operator</code> generator of IMSRG flow (antihermite Operator)</li><li><code>Omega::Operator</code> generator of IMSRG flow (antihermite Operator) </li><li><code>eta_criterion::Float</code> ||eta|| to check convergence</li><li><code>denominatorDelta::Float64</code> parameter for multi-major shell decoupling</li><li><code>n_written_omega::Int</code> # of written Omega by splitting to solve IMSRGflow</li><li><code>Ncomm::Vector{Int}</code> # of commutator evaluated during IMSRG flow</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L281-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.ModelSpace" href="#NuclearToolkit.ModelSpace"><code>NuclearToolkit.ModelSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>ModelSpace</code></p><p><strong>Fields</strong></p><ul><li><code>p_sps::Vector{SingleParticleState}</code> proton single particle states (only odd integer)</li><li><code>n_sps::Vector{SingleParticleState}</code> neutron single particle states</li><li><code>sps::Vector{SingleParticleState}</code> single particle states (odd number ones=&gt;proton even=&gt;neutron)</li><li><code>occ_p::Matrix{Float64}</code> matrix representing the occupation number of proton (needed for density matrix)</li><li><code>occ_n::Matrix{Float64}</code> matrix representing the occupation number of neutron</li><li><code>holes::Vector{Vector{Int64}}</code> idx list of holes</li><li><code>particles::Vector{Vector{Int64}}</code> idx list of particles</li><li><code>spaces::space_channel</code> space_channel (mutable struct)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L216-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Operator" href="#NuclearToolkit.Operator"><code>NuclearToolkit.Operator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>mutable struct <code>Operator</code></p><p><strong>Fields</strong></p><ul><li><code>zerobody::Vector{Float64}</code> zerobody part of the operator</li><li><code>onebody::Vector{Matrix{Float64}}</code> one-body matrix elements ([1]=&gt;proton, [2]=&gt;neutron)</li><li><code>twobody::Vector{Matrix{Float64}}</code> two-body matrix elements, having array structure [ch]</li><li><code>hermite::Bool</code> whether it is hermitian operator or not</li><li><code>antihermite::Bool</code> antihermitian or not</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L239-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.PandyaObject" href="#NuclearToolkit.PandyaObject"><code>NuclearToolkit.PandyaObject</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>PandyaObject</code>, used for Pandya transformation (especially in <code>comm222ph_ss!</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L104-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.SingleParticleState" href="#NuclearToolkit.SingleParticleState"><code>NuclearToolkit.SingleParticleState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>mutable struct <code>SingleParticleState</code></p><p><strong>Fields</strong></p><ul><li><code>n::Int64</code> principal quantum number of the single particle state(sps)</li><li><code>l::Int64</code> azimuthal quantum number of the sps</li><li><code>j::Int64</code> angular momentum</li><li><code>tz::Int64</code> z-component of isospin (doubled) tz=-1 =&gt; proton &amp; tz=1 =&gt; neutron</li><li><code>occ::Int64</code> occupation number (0 or 1 for now, fractional occupation has not yet implemented) of the sps</li><li><code>c::Bool</code> indicating whether the single-particle state belongs to &quot;core&quot; or not </li><li><code>v::Bool</code> whether belongs to &quot;valence&quot; or not </li><li><code>q::Bool</code> whether belongs to &quot;q-space&quot; or not </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.VdictCh" href="#NuclearToolkit.VdictCh"><code>NuclearToolkit.VdictCh</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>VdictCh</code></p><p><strong>Fields</strong></p><ul><li><code>Vch::Int64</code> two-body channel (specified by JPT)</li><li><code>Vdict::Dict{Vector{Int64},Int64}</code> dict to get idx from ket like |1,5&gt;:=[1,5]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.basedat" href="#NuclearToolkit.basedat"><code>NuclearToolkit.basedat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>basedat</code> contains base infomation of the calculation</p><p><strong>Fields</strong></p><ul><li><code>nuc::nuclei</code> information of target/core nucleus </li><li><code>sntf::String</code> filename/path to input interaction</li><li><code>hw::Int64</code> hbar omega parameter used to define single particle states</li><li><code>emax::Int64</code> emax truncation for the entire calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.chan1b" href="#NuclearToolkit.chan1b"><code>NuclearToolkit.chan1b</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>chan1b</code> </p><p><strong>Fields</strong></p><ul><li><code>chs1b::Vector{Dict{Int64,Vector{Int64}}}</code> dict of single particle states with non-zero contribution (having same l,j) [dict for proton sps, dict for neutron sps]</li><li><code>chs1b_redundant::Vector{Dict{Int64,Vector{Int64}}}</code> redundant version of chs1b (with i&gt;j case)</li><li><code>snt2ms::Dict{Int64,Int64}</code> map from snt idx to modelspace(ms) idx</li><li><code>ms2snt::Dict{Int64,Int64}</code> map from ms idx to snt idx</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.chan2b" href="#NuclearToolkit.chan2b"><code>NuclearToolkit.chan2b</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>chan2b</code> referred to as &quot;tbc&quot; (two-body channel) in some functions</p><p><strong>Fields</strong></p><ul><li><code>Tz::Int64</code> total tz, -2(pp),0(pn),2(n)</li><li><code>prty::Int64</code> parity</li><li><code>J::Int64</code> total J</li><li><code>kets::Vector{Vector{Int64}}</code> vector of ket (e.g. [1,1], [1,3],...)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.dWS2n" href="#NuclearToolkit.dWS2n"><code>NuclearToolkit.dWS2n</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>dWS2n</code>, Wigner symbols used in PreCalcHOB</p><p><strong>Fields</strong></p><ul><li><code>dtri::Dict{Vector{Int64},Float64}</code> dict for trinomial </li><li><code>dcgm0::Dict{Vector{Int64},Float64}</code> dict for special CG coefficients</li><li><code>keycg::Vector{Vector{Int64}}</code> array of key for cg</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L312-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.dictSnt" href="#NuclearToolkit.dictSnt"><code>NuclearToolkit.dictSnt</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>dictTBMEs</code> contains dictionaries for TBME/monopole</p><p><strong>Fields</strong></p><ul><li><code>dictTBMEs::Vector{Dict{Vector{Int64},Float64}}</code> one can get pp/pn/nn dict by <code>dictTBMEs[pnrank]</code> (<code>pnrank=1,2,3</code>)</li><li><code>dictMonopole::Vector{Dict{Vector{Int64},valDictMonopole}}</code> one can get monopole component of two-body interaction by <code>dictMonopole[pnrank][key]</code>, <code>key</code> to be ket array like <code>[1,1]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.hfdata" href="#NuclearToolkit.hfdata"><code>NuclearToolkit.hfdata</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>hfdata</code>, used to calculate multiple nuclei in a single runscript</p><p><strong>Fields</strong></p><ul><li><code>nuc::nuclei</code> information of target/core nucleus</li><li><code>data::Vector{Vector{Float64}}</code> will be experimental data from AME2020 (if available)</li><li><code>datatype::Vector{String}</code> supposed to be [&quot;E&quot;] for now</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L154-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.nuclei" href="#NuclearToolkit.nuclei"><code>NuclearToolkit.nuclei</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>nuclei</code></p><p><strong>Fields</strong></p><ul><li><code>Z::Int64</code> proton number of the reference nucleus</li><li><code>N::Int64</code> neutron number of the ref.</li><li><code>A::Int64</code> mass number of the ref.</li><li><code>el::String</code> element (e.g., &quot;He&quot;)</li><li><code>cnuc::String</code> string element nameA (e.g., &quot;He8&quot;)</li><li><code>cZ::Int64</code> proton number of core nucleus </li><li><code>cN::Int64</code> neutron number of core</li><li><code>corenuc::String</code> core nucleus (e.g., &quot;He4&quot;)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.single_util122" href="#NuclearToolkit.single_util122"><code>NuclearToolkit.single_util122</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct <code>single_util122</code>, used to make operation related commutator122 matrix manipulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L93-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.space_channel" href="#NuclearToolkit.space_channel"><code>NuclearToolkit.space_channel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>mutable struct <code>space_channel</code>; dictionaries to get the two-body channels that have kets (specified by pp,ph, etc.)</p><p><strong>Fields</strong></p><ul><li><code>pp::Dict{Int64,Vector{Int64}}</code> particle-particle</li><li><code>ph::Dict{Int64,Vector{Int64}}</code> particle-hole </li><li><code>hh::Dict{Int64,Vector{Int64}}</code> hole-hole</li><li><code>cc::Dict{Int64,Vector{Int64}}</code> core-core</li><li><code>vc::Dict{Int64,Vector{Int64}}</code> valence-core</li><li><code>qc::Dict{Int64,Vector{Int64}}</code> qspace-core</li><li><code>vv::Dict{Int64,Vector{Int64}}</code> valence-valence</li><li><code>qv::Dict{Int64,Vector{Int64}}</code> qspace-valence</li><li><code>qq::Dict{Int64,Vector{Int64}}</code> qspace-qspace</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/def_struct.jl#L167-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.HF_MBPT2-NTuple{8, Any}" href="#NuclearToolkit.HF_MBPT2-NTuple{8, Any}"><code>NuclearToolkit.HF_MBPT2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HF_MBPT2(binfo,modelspace,fp,fn,e1b_p,e1b_n,Chan2b,Gamma)</code></pre><p>Calculate 2nd order correction to HF energy</p><p class="math-container">\[E^{(2)} = \frac{1}{4}\sum_{abij} \frac{\bar{H}^{[2]}_{abij} \bar{H}^{[2]}_{ijab}}{\epsilon^{ab}_{ij}} = \frac{1}{4} \sum_{\tilde{a}\tilde{b}\tilde{i}\tilde{j}}\sum_{\{m\}}\sum_{JJ&#39;MM&#39;}
\frac{{}^J\bar{H}^{[2]}_{\tilde{a}\tilde{b}\tilde{i}\tilde{j}} {}^J\bar{H}^{[2]}_{\tilde{i}\tilde{j}\tilde{a}\tilde{b}}}{\epsilon^{ab}_{ij}}
(j_a j_b m_a m_b|J M)
(j_a j_b m_a m_b|J&#39; M&#39;)
(j_i j_j m_i m_j|J M)
(j_i j_j m_i m_j|J&#39; M&#39;)\]</p><p class="math-container">\[=
\frac{1}{4} \sum_{\tilde{a}\tilde{b}\tilde{i}\tilde{j}}\sum_{JJ&#39;MM&#39;}
\frac{{}^J\bar{H}^{[2]}_{\tilde{a}\tilde{b}\tilde{i}\tilde{j}} {}^{J&#39;}\bar{H}^{[2]}_{\tilde{i}\tilde{j}\tilde{a}\tilde{b}}}{\epsilon^{ab}_{ij}}
\delta_{JJ&#39;} \delta_{MM&#39;} = \frac{1}{4} \sum_{\tilde{a}\tilde{b}\tilde{i}\tilde{j}}\sum_{J}(2J+1)
\frac{{}^J\bar{H}^{[2]}_{\tilde{a}\tilde{b}\tilde{i}\tilde{j}} {}^J\bar{H}^{[2]}_{\tilde{i}\tilde{j}\tilde{a}\tilde{b}}}{\epsilon^{ab}_{ij}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/hf_mbpt.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.HF_MBPT3-NTuple{9, Any}" href="#NuclearToolkit.HF_MBPT3-NTuple{9, Any}"><code>NuclearToolkit.HF_MBPT3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HF_MBPT3(binfo,modelspace,e1b_p,e1b_n,Chan2b,dict_2b_ch,dict6j,Gamma,to)</code></pre><p>Calculate 2nd order correction to HF energy</p><p class="math-container">\[E^{(3)}=
\frac{1}{8} 
\sum_{\tilde{a}\tilde{b}\tilde{c}\tilde{i}\tilde{j}\tilde{k}} \sum_{J}(2J+1)
\frac{
{}^{J}\bar{H}^{[2]}_{\tilde{a}\tilde{b}\tilde{i}\tilde{j}} 
{}^{J}\bar{H}^{[2]}_{\tilde{i}\tilde{j}\tilde{c}\tilde{d}}
{}^{J}\bar{H}^{[2]}_{\tilde{c}\tilde{d}\tilde{a}\tilde{b}} 
}
{\epsilon^{\tilde{a}\tilde{b}}_{\tilde{i}\tilde{j}}\epsilon^{\tilde{c}\tilde{d}}_{\tilde{i}\tilde{j}}}
+
\frac{1}{8} 
\sum_{\tilde{a}\tilde{b}\tilde{i}\tilde{j}\tilde{k}\tilde{l}} \sum_{J}(2J+1)
\frac{
{}^{J}\bar{H}^{[2]}_{\tilde{i}\tilde{j}\tilde{a}\tilde{b}} 
{}^{J}\bar{H}^{[2]}_{\tilde{a}\tilde{b}\tilde{k}\tilde{l}}
{}^{J}\bar{H}^{[2]}_{\tilde{k}\tilde{l}\tilde{i}\tilde{j}} 
}
{\epsilon^{\tilde{a}\tilde{b}}_{\tilde{i}\tilde{j}}\epsilon^{\tilde{c}\tilde{d}}_{\tilde{i}\tilde{j}}}
-\sum_{\tilde{a}\tilde{b}\tilde{c}\tilde{i}\tilde{j}\tilde{k}} \sum_{J}(2J+1)
\frac{
{}^JH^{XC}_{\tilde{a}\tilde{i}\tilde{j}\tilde{b}}
{}^JH^{XC}_{\tilde{j}\tilde{b}\tilde{k}\tilde{c}}
{}^JH^{XC}_{\tilde{k}\tilde{c}\tilde{a}\tilde{i}}
}{
\epsilon^{\tilde{a}\tilde{b}} \epsilon_{\tilde{i}\tilde{j}}
\epsilon^{\tilde{a}\tilde{c}} \epsilon_{\tilde{k}\tilde{j}}
}\]</p><p>Ref. Many-Body Methods in Chemistry and Physics by Isaiah Shavitt and Rodney J. Bartlett (2009, Cambridge Molecular Science). More details can be found in e.g. Dr. thesis by A.Tichai (2017, TU Darmstadt).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/hf_mbpt.jl#L81-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.vPandya-NTuple{15, Any}" href="#NuclearToolkit.vPandya-NTuple{15, Any}"><code>NuclearToolkit.vPandya</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vPandya(a,b,c,d,ja,jb,jc,jd,totJ,dict_2b_ch,tdict6j,Gamma,keych,key6j,keyab;verbose=false)</code></pre><p>returns generalized Pandya transformed matrix element:</p><p class="math-container">\[\tilde{V}^J_{ajib} = -\sum_{J&#39;} [J&#39;] 
\begin{Bmatrix} 
j_a &amp; j_j &amp; J \\
j_i &amp; j_d &amp; J&#39;
\end{Bmatrix}
V^{J&#39;}_{abij}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/hf_mbpt.jl#L253-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.cZN_from_corenuc-Tuple{Any, Any, Any}" href="#NuclearToolkit.cZN_from_corenuc-Tuple{Any, Any, Any}"><code>NuclearToolkit.cZN_from_corenuc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cZN_from_corenuc(rZ,rN,corenuc)</code></pre><p>get <span>$Z$</span> and <span>$N$</span> of the core nucleus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.def_chan1b-Tuple{Any, Any, Any}" href="#NuclearToolkit.def_chan1b-Tuple{Any, Any, Any}"><code>NuclearToolkit.def_chan1b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">def_chan1b(dim1b,sps,dicts1b)</code></pre><p>define Chan1b: dict. to get 1b-channels to be coupled to a given channel Chan1b = [ dict<em>for</em>proton<em>sps, dict</em>for<em>neutron</em>sps] dicts1b Basically ToBeCoupled will be used, but redundant one is needed in some cases</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L456-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.def_chan2b-NTuple{4, Any}" href="#NuclearToolkit.def_chan2b-NTuple{4, Any}"><code>NuclearToolkit.def_chan2b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">def_chan2b(binfo,dicts,sps,Chan1b)</code></pre><p>define two-body utils and returns them as <code>Chan2bD</code> struct </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L504-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.def_nuc-NTuple{4, Any}" href="#NuclearToolkit.def_nuc-NTuple{4, Any}"><code>NuclearToolkit.def_nuc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">def_nuc(Z,N,ref,corenuc)</code></pre><p>constructor of <code>nuclei</code> strict from given <code>Z</code>,<code>N</code>,<code>ref</code>,<code>corenuc</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.def_nuc-Tuple{Any, Any, Any}" href="#NuclearToolkit.def_nuc-Tuple{Any, Any, Any}"><code>NuclearToolkit.def_nuc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">def_nuc(Z,N,ref,corenuc)</code></pre><p>constructor of <code>nuclei</code> strict from given <code>cnuc</code>,<code>ref</code>,<code>corenuc</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.get_ZNref-NTuple{4, Any}" href="#NuclearToolkit.get_ZNref-NTuple{4, Any}"><code>NuclearToolkit.get_ZNref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_ZNref(ref,Z,N,corenuc)</code></pre><p>get <span>$Z$</span> and <span>$N$</span> of the target reference</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.make_sps_and_dict_isnt2ims-Tuple{Any, Any, Any}" href="#NuclearToolkit.make_sps_and_dict_isnt2ims-Tuple{Any, Any, Any}"><code>NuclearToolkit.make_sps_and_dict_isnt2ims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_sps_and_dict_isnt2ims(p_sps,n_sps,lp)</code></pre><p>make dicts1b, snt-idx(sntidx) = 1-lp (proton) &amp; lp+1~lp+ln (neutron), modelspace-idx(msidx) = odd(1,3,...)-&gt; proton, even(2,4,...) -&gt; neutron</p><p>returns:</p><ul><li><code>dict_snt2ms</code>: from sntidx to msidx </li><li><code>dict_ms2snt</code>: from msidx to sntidx</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L189-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.make_sps_from_pnsps-Tuple{Any, Any, Any}" href="#NuclearToolkit.make_sps_from_pnsps-Tuple{Any, Any, Any}"><code>NuclearToolkit.make_sps_from_pnsps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_sps_from_pnsps(p_sps,n_sps,Chan1b)</code></pre><p>construct <code>sps</code> from <code>p_sps</code> and <code>n_sps</code></p><p>It may be better to unify the rule whther sps to be constructed &quot;referring&quot; or &quot;copying&quot; p<em>sps/n</em>sps. (For now it does not matter.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L211-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.readsnt-Tuple{Any, Any, Any}" href="#NuclearToolkit.readsnt-Tuple{Any, Any, Any}"><code>NuclearToolkit.readsnt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readsnt(sntf,binfo,to)</code></pre><p>Function to read snt file. Note that it is slightly different from <code>readsnt()</code> in ShellModel.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.readsnt_bin-Tuple{Any, Any, Any}" href="#NuclearToolkit.readsnt_bin-Tuple{Any, Any, Any}"><code>NuclearToolkit.readsnt_bin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readsnt(sntf,binfo,to)</code></pre><p>Function to read snt.bin file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.rm_comment-Tuple{Any}" href="#NuclearToolkit.rm_comment-Tuple{Any}"><code>NuclearToolkit.rm_comment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rm_comment(lines)</code></pre><p>remove fortran like comment from input (snt fmt) strings</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L93-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.store_1b2b-NTuple{4, Any}" href="#NuclearToolkit.store_1b2b-NTuple{4, Any}"><code>NuclearToolkit.store_1b2b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">store_1b2b(sps,dicts1b,dicts,binfo)</code></pre><p>Function summarize data from input snt/snt.bin file.It returns</p><ul><li><code>Hamil::Operator</code> input interaction</li><li><code>dictsnt</code> dict to get TBMEs and monopole components</li><li><code>Chan1b</code> struct chan1b</li><li><code>Chan2bD</code> struct chan2b </li><li><code>Gamma</code> preallocated two-body density matrices</li><li><code>maxnpq</code> maximum size of length(kets) for two-body channels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L325-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.update_1b!-Tuple{Any, Any, Any}" href="#NuclearToolkit.update_1b!-Tuple{Any, Any, Any}"><code>NuclearToolkit.update_1b!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_1b!(binfo,sps,Hamil)</code></pre><p>Update one-body(1b) part of Hamiltonian for different target nuclei</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L604-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.update_2b!-NTuple{6, Any}" href="#NuclearToolkit.update_2b!-NTuple{6, Any}"><code>NuclearToolkit.update_2b!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_2b!(binfo,sps,Hamil,dictTBMEs,Chan2bD,dicts)</code></pre><p>Update two-body(2b) part of Hamiltonian for different target nuclei</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/io_input.jl#L638-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.ReorderHFSPS!-NTuple{7, Any}" href="#NuclearToolkit.ReorderHFSPS!-NTuple{7, Any}"><code>NuclearToolkit.ReorderHFSPS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ReorderHFSPS!(h_p,h_n,Cp,Cn,e1b_p,e1b_n,Chan1b)</code></pre><p>&quot;reorder&quot; HF single particle space. Since we diagonalize the <code>h_p,h_n</code> (istead of subblock mat), we need to specify the correspondance between ordering of sps and that of HFSPEs obtained by solving HF eigenvalue problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L301-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.add_ch_ket!-Tuple{Any, Any, Any}" href="#NuclearToolkit.add_ch_ket!-Tuple{Any, Any, Any}"><code>NuclearToolkit.add_ch_ket!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_ch_ket!(ch,iket,tdict)</code></pre><p>add ch &amp; idx for kets in <code>spaces::space_channel</code> (pp/hh/etc.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L498-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.calc_Gamma!-NTuple{7, Any}" href="#NuclearToolkit.calc_Gamma!-NTuple{7, Any}"><code>NuclearToolkit.calc_Gamma!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_Gamma!(Gamma,sps,Cp,Cn,V2,Chan2b,maxnpq)</code></pre><p>calculate <span>$\Gamma$</span> (two-body HF interaction)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L432-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.def_holeparticle-NTuple{5, Any}" href="#NuclearToolkit.def_holeparticle-NTuple{5, Any}"><code>NuclearToolkit.def_holeparticle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">def_holeparticle(Chan1b,occ_p,occ_n,p_sps,n_sps)</code></pre><p>define hole/particle space by <code>occ_p, occ_n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.def_sps-Tuple{Any}" href="#NuclearToolkit.def_sps-Tuple{Any}"><code>NuclearToolkit.def_sps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">def_sps(emax)</code></pre><p>Function to define <code>sps::Vector{SingleParticleState}</code> from <code>emax</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L162-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.getHNO-Union{Tuple{tChan2b}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, tChan2b, Any, Any, Any, Any, Any}} where tChan2b&lt;:Vector{NuclearToolkit.chan2b}" href="#NuclearToolkit.getHNO-Union{Tuple{tChan2b}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, tChan2b, Any, Any, Any, Any, Any}} where tChan2b&lt;:Vector{NuclearToolkit.chan2b}"><code>NuclearToolkit.getHNO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getHNO(binfo,tHFdata,E0,p_sps,n_sps,occ_p,occ_n,h_p,h_n,e1b_p,e1b_n,Cp,Cn,V2,Chan1b,Chan2b::tChan2b,Gamma,maxnpq,dict_2b_ch,dict6j,to) where{tChan2b &lt;: Vector{chan2b}}</code></pre><p>obtain spherical HF solution and calc. MBPT correction (upto 2nd&amp;3rd order) to g.s. energy</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L543-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.get_space_chs-Tuple{Any, Any}" href="#NuclearToolkit.get_space_chs-Tuple{Any, Any}"><code>NuclearToolkit.get_space_chs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_space_chs(sps,Chan2b)</code></pre><p>define hole/particle single particle states. In this function, only the hh/pp/ph (needed for IMSRG) are defined, and other channels will be updated later for target normal ordering or VS-IMSRG flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L513-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.hf_iteration-NTuple{11, Any}" href="#NuclearToolkit.hf_iteration-NTuple{11, Any}"><code>NuclearToolkit.hf_iteration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hf_iteration(binfo,tHFdata,sps,Hamil,dictTBMEs,Chan1b,Chan2bD,Gamma,maxnpq,dict6j,to;itnum=100,verbose=false,HFtol=1.e-14,inttype=&quot;snt&quot;)</code></pre><p>solve HF equation</p><p>This function returns object with HamiltonianNormalOrdered (HNO) struct type, which contains...</p><ul><li><code>E0,EMP2,EMP3</code> HF energy and its MBPT corrections</li><li><code>fp/fn::Matrix{Float64}</code> one-body int.</li><li><code>Gamma:: Vector{Matrix{Float64}}</code> two-body int.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L580-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.hf_main-NTuple{4, Any}" href="#NuclearToolkit.hf_main-NTuple{4, Any}"><code>NuclearToolkit.hf_main</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hf_main(nucs,sntf,hw,emax;verbose=false,Operators=String[],is_show=false,doIMSRG=false,valencespace=[],corenuc=&quot;&quot;,ref=&quot;nucl&quot;)</code></pre><p>main function to carry out HF/HFMBPT calculation from snt file</p><p><strong>Arguments</strong></p><ul><li><code>nucs::Vector{String}</code> target nuclei</li><li><code>sntf</code> path to input interaction file</li><li><code>hw</code> hbar omega</li><li><code>emax</code> emax for HF/IMSRG</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>verbose=false</code> to see detailed stdout for HF</li><li><code>Operators=String[]</code> target observables other than Hamiltonian</li><li><code>is_show=false</code> to show TimerOutput log (summary of run time and memory allocation)</li><li><code>doIMSRG=false</code> to carry out IMSRG/VSIMSRG calculation </li><li><code>valencespace=[]</code> to spacify the valence space (e.g., [&quot;sd-shell&quot;]), if this is not empty, it tries to do vsimsrg calculations</li><li><code>corenuc=&quot;&quot;</code> core nucleus, example=&gt; &quot;He4&quot;</li><li><code>ref=&quot;nucl&quot;</code> to specify target reference state, &quot;core&quot; or &quot;nucl&quot; is supported</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.hf_main_mem-NTuple{6, Any}" href="#NuclearToolkit.hf_main_mem-NTuple{6, Any}"><code>NuclearToolkit.hf_main_mem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hf_main_mem(chiEFTobj,nucs,dict_TM,dict6j,HFdata,to;verbose=false,Operators=String[],valencespace=[],corenuc=&quot;&quot;,ref=&quot;core&quot;)</code></pre><p>&quot;without I/O&quot; version of <code>hf_main</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.ini_occ!-NTuple{4, Any}" href="#NuclearToolkit.ini_occ!-NTuple{4, Any}"><code>NuclearToolkit.ini_occ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ini_occ!(pconfs,occ_p,nconfs,occ_n)</code></pre><p>initialize occupation number matrices (<code>occ_p</code>&amp;<code>occ_n</code>) by naive filling configurations <code>pconfs</code>&amp;<code>nconfs</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.naive_filling" href="#NuclearToolkit.naive_filling"><code>NuclearToolkit.naive_filling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">naive_filling(sps,n_target,emax,for_ref=false)</code></pre><p>calculate naive filling configurations by given sps and proton/neutron number (<code>n_target</code>)</p><p>For some nuclei, carrying out naive filling is ambiguous (e.g., neutron occupation of 22O can be both 0s1(2),0p1(2),0p3(4),0d5(6) and  0s1(2),0p1(2),0p3(4),1s1(2), 0d3(4)). In this function, &quot;naive filling&quot; means to try fill orbits with lower <span>$2n+l$</span> and then &quot;lower&quot; <span>$j$</span>. The occupations will be updated when solving HF.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L209-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.prepHFdata-NTuple{4, Any}" href="#NuclearToolkit.prepHFdata-NTuple{4, Any}"><code>NuclearToolkit.prepHFdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepHFdata(nucs,ref,datatype,corenuc)</code></pre><p>Constructor of an array of <code>hfdata</code> struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.printEHF-Tuple{Any}" href="#NuclearToolkit.printEHF-Tuple{Any}"><code>NuclearToolkit.printEHF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printEHF(Es)</code></pre><p>print HF energy and its break down <code>Es=[E1b,E2bpp,E2bnn,E2bpn]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L655-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.recalc_v!-Tuple{Any, Any}" href="#NuclearToolkit.recalc_v!-Tuple{Any, Any}"><code>NuclearToolkit.recalc_v!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recalc_v!(A,dicts)</code></pre><p>Function to calculate two-body interaction from snt file. This is needed because in the readsnt/readsnt_bin function, the interaction part and the kinetic term  are stored separately to avoid multiple reads of the input file when calculating multiple nuclei.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.update_occ!-NTuple{8, Any}" href="#NuclearToolkit.update_occ!-NTuple{8, Any}"><code>NuclearToolkit.update_occ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_occ!(pconfs,nconfs,p_sps,n_sps,occ_p,occ_n,e1b_p,e1b_n)</code></pre><p>update occupation matrices by HF SPEs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/main.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Calc_Expec-NTuple{7, Any}" href="#NuclearToolkit.Calc_Expec-NTuple{7, Any}"><code>NuclearToolkit.Calc_Expec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Calc_Expec(binfo,Chan1b,Chan2b,HFobj,Op_Rp2,dict_2b_ch,dict6j;hfmbptlevel=true,verbose=false)</code></pre><p>Calculate expectation value of Rp2 and its HFMBPT corrections.</p><p>Details about HFMBPT correction can be found in  Many-Body Methods in Chemistry and Physics by Isaiah Shavitt and Rodney J. Bartlett (2009, Cambridge Molecular Science)  or Appendix in <a href="https://doi.org/10.1103/PhysRevC.105.014302">T. Miyagi et al., Phys. Rev. C 105, 0143022 (2022)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L209-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Calculate_RCM-NTuple{8, Any}" href="#NuclearToolkit.Calculate_RCM-NTuple{8, Any}"><code>NuclearToolkit.Calculate_RCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Calculate_RCM(binfo,Chan1b,Chan2b,HFobj,Op_Rp2,d9j,HOBs,to;non0_cm=true,non0_ij=true)</code></pre><p>calculate <span>$R_{CM}$</span> term</p><p>Note that rirj term is also included here to avoid redundancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Calculate_Rp-NTuple{10, Any}" href="#NuclearToolkit.Calculate_Rp-NTuple{10, Any}"><code>NuclearToolkit.Calculate_Rp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Calculate_Rp(binfo,Chan1b,Chan2b,HFobj,Op_Rp2,dict_9j_2n,HOBs,dict_2b_ch,dict6j,to;hfmbptlevel=true)</code></pre><p>To calculate squared point proton radius and its MBPT correction. The squared point proton radius is related to the charge radius as follows</p><p class="math-container">\[R^2_{ch} = R^2_p + \langle r^2_p \rangle + \frac{N}{Z} \langle r^2_n \rangle + \frac{3}{4m^2_p c^4} 
+ \langle r^2 \rangle_{SO},\]</p><p>where <span>$\langle r^2_p \rangle = 0.769 \mathrm{fm}^2$</span>, <span>$\langle r^2_n \rangle = -0.116 \mathrm{fm}^2$</span>, <span>$\frac{3}{4m^2_p c^4} =0.033\mathrm{fm}^2$</span> is the so-called Darwin-Foldy term, and the last term is Spin-Orbit correction term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L614-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Calculate_SOterm-NTuple{4, Any}" href="#NuclearToolkit.Calculate_SOterm-NTuple{4, Any}"><code>NuclearToolkit.Calculate_SOterm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Calculate_SOterm(binfo,Chan1b,HFobj,Op_Rp2)</code></pre><p>Calculate Spin-Orbit Correction term for Rp2. We are using &quot;simple expression for the correction to the mean-square charge radius due to the spin-orbit term&quot; in the reference below:</p><p class="math-container">\[\langle r^2 \rangle_{SO} =-\frac{1}{Z}\sum_i \frac{\mu_i}{M^2} (\kappa_i+1),\]</p><p>where <span>$\mu_p = 2.793 \mu_N$</span>, <span>$\mu_n = −1.913\mu_N$</span>, and <span>$\kappa = \ell (\mathrm{for } j=\ell-1/2), -(\ell+1) (\mathrm{for} j=\ell+1/2)$</span></p><p>Ref: A.Ong, J.C.Berengut, and V.V.Flambaum, <a href="https://doi.org/10.1103/PhysRevC.82.014320">Phys. Rev. C 82, 014320 (2010)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L175-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Calculate_intR2p-NTuple{4, Any}" href="#NuclearToolkit.Calculate_intR2p-NTuple{4, Any}"><code>NuclearToolkit.Calculate_intR2p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Calculate_intR2p(binfo,Chan1b,HFobj,Op_Rp2)</code></pre><p>calculate a part of squared point proton radius R2p. Note that this function overwrites the onebody part of given <code>Op_Rp2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.InitOp-Tuple{Any, Any}" href="#NuclearToolkit.InitOp-Tuple{Any, Any}"><code>NuclearToolkit.InitOp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InitOp(Chan1b,Chan2b)</code></pre><p>initialize scaler Operator, note that hermite is true as default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.aOp!-Tuple{NuclearToolkit.Operator, Float64}" href="#NuclearToolkit.aOp!-Tuple{NuclearToolkit.Operator, Float64}"><code>NuclearToolkit.aOp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aOp!(Op::Operator,a::Float64)</code></pre><p>function to multiply scaler to an operator::Operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.aOp1_p_bOp2!-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64}" href="#NuclearToolkit.aOp1_p_bOp2!-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64}"><code>NuclearToolkit.aOp1_p_bOp2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aOp1_p_bOp2!(Op1::Operator,Op2::Operator,a::Float64,b::Float64)</code></pre><p>function to overwrite <code>Op2</code> by <code>a*Op1 + b*Op2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.aOp1_p_bOp2_Op3!-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64, Float64}" href="#NuclearToolkit.aOp1_p_bOp2_Op3!-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64, Float64}"><code>NuclearToolkit.aOp1_p_bOp2_Op3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aOp1_p_bOp2_Op3!(Op1::Operator,Op2::Operator,Op3::Operator,a::Float64,b::Float64,c::Float64)</code></pre><p>function to overwrite <code>Op3</code> by <code>c*Op3 + a*Op1 + b*Op2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.calc_single_r1r2-NTuple{8, Any}" href="#NuclearToolkit.calc_single_r1r2-NTuple{8, Any}"><code>NuclearToolkit.calc_single_r1r2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_single_r1r2(bra,ket,sps,J,dict_9j_2n,HOBs,b2,to)</code></pre><p>Calc <span>$&lt;r_1 \cdot r_2&gt;$</span> for a given 2b-channel.</p><ul><li><code>bra</code>: &lt;ab| a&amp;b: s.p.s. (n,l,j,tz)</li><li><code>ket</code>: |cd&gt; c&amp;d: s.p.s. (n,l,j,tz)</li><li><code>dictWS</code>: dict of WignerSymobls</li><li><code>d9j</code>: 9j-symbols (array of J-&gt;S and key=[la,ja,lb,jb,L])</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L510-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.eval_rch_hfmbpt-NTuple{9, Any}" href="#NuclearToolkit.eval_rch_hfmbpt-NTuple{9, Any}"><code>NuclearToolkit.eval_rch_hfmbpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_rch_hfmbpt(binfo,Chan1b,Chan2bD,HFobj,Op_Rp2,dict_9j_2n,HOBs,dict6j,to)</code></pre><p>evaluate charge radii with HFMBPT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L634-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.eval_rch_imsrg-NTuple{11, Any}" href="#NuclearToolkit.eval_rch_imsrg-NTuple{11, Any}"><code>NuclearToolkit.eval_rch_imsrg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_rch_imsrg(binfo,Chan1b,Chan2bD,HFobj,IMSRGobj,PandyaObj,dict_9j_2n,HOBs,dictMono,dict6j,to)</code></pre><p>evaluate charge radii with IMSRG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L660-L664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.getNormalOrderedO-NTuple{7, Any}" href="#NuclearToolkit.getNormalOrderedO-NTuple{7, Any}"><code>NuclearToolkit.getNormalOrderedO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNormalOrderedO(binfo,HFobj,targetOp,Chan1b,Chan2bD,dict6j,to;verbose=false,undo=false,OpeqH=false,firstNO=false)</code></pre><p>NormalOrdering for a target Operator. For now, it only supports scaler operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L703-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.show_Hamil_norm-Tuple{NuclearToolkit.Operator}" href="#NuclearToolkit.show_Hamil_norm-Tuple{NuclearToolkit.Operator}"><code>NuclearToolkit.show_Hamil_norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_Hamil_norm(Op::Operator;tol=1.e-6,normtype=&quot;fro&quot;)</code></pre><p>Function to show 1b/2b norm of a given Operator. It may be usuful for debug.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/hartreefock.jl/operator.jl#L801-L805">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ChiEFTint.html">« ChiEFTint</a><a class="docs-footer-nextpage" href="IMSRG.html">IMSRG »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Monday 23 May 2022 09:58">Monday 23 May 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
