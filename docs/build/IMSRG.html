<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IMSRG · NuclearToolkit.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://SotaYoshida.github.io/NuclearToolkit.jl/IMSRG.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="NuclearToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">NuclearToolkit.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="ChiEFTint.html">ChiEFTint</a></li><li><a class="tocitem" href="HartreeFock.html">HartreeFock</a></li><li class="is-active"><a class="tocitem" href="IMSRG.html">IMSRG</a></li><li><a class="tocitem" href="ShellModel.html">ShellModel</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="IMSRG.html">IMSRG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="IMSRG.html">IMSRG</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/master/docs/src/IMSRG.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="IMSRG"><a class="docs-heading-anchor" href="#IMSRG">IMSRG</a><a id="IMSRG-1"></a><a class="docs-heading-anchor-permalink" href="#IMSRG" title="Permalink"></a></h1><p>Functions for IM-SRG calculations</p><ul><li><a href="../../src/IMSRG.jl/imsrg_util.jl">imsrg_util.jl</a>: contains main and util functions </li><li><a href="../../src/IMSRG.jl/commutator.jl">commutator.jl</a>: functions to calculate commutators and BCH transform to carry out IMSRG flow with Magnus expansion</li><li><a href="../../src/IMSRG.jl/valencespace.jl">valencespace.jl</a>: functions for Valence-space IM-SRG (VS-IMSRG) calculations to derive shell-model effective interactions/operators</li></ul><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.BCH_Product-NTuple{14, Any}" href="#NuclearToolkit.BCH_Product-NTuple{14, Any}"><code>NuclearToolkit.BCH_Product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BCH_Product(X,Y,Z,tmpOp,Nested,ncomm,norms,Chan1b,Chan2bD,HFobj,dictMono,dict6j,PandyaObj,to;tol=1.e-4)</code></pre><p>returns <span>$Z$</span>  to satisfy: <span>$e^Z = e^X e^Y$</span>  </p><p><span>$Z$</span> is calculated with Baker–Campbell–Hausdorff (BCH) formula:</p><p><span>$Z = X + Y + 1/2[X, Y]  + 1/12 [X,[X,Y]] + 1/12 [Y,[Y,X]] -1/24 [Y,[X,[X,Y]]] -1/720 [Y,[Y,[Y,[Y,X]]]] -1/720 [X,[X,[X,[X,Y]]]] +...$</span></p><p>For IMSRG flow of <span>$H(s)$</span>, <span>$X=\eta(s)*ds$</span>, <span>$Y=\Omega(s)$</span>, and <span>$Z=\Omega(s+ds)$</span> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.BCH_Transform-NTuple{14, Any}" href="#NuclearToolkit.BCH_Transform-NTuple{14, Any}"><code>NuclearToolkit.BCH_Transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BCH_Transform(Omega,O0,Hs,tOp,Nested,ncomm,norms,Chan1b,Chan2bD,HFobj,dictMono,dict6j,PandyaObj,to;tol=1.e-9,maxit=50,verbose=false)</code></pre><p>Update <span>$B$</span> (assumed to be <span>$H$</span> or <span>$O$</span>) via <span>$e^ABe^{-A} =B+[A,B]+1/2![A,[A,B]]+1/3![A,[A,[A,B]]]+...$</span></p><p>It needs 3 copy to store (k-1)-th adj./k-th adj./ret.</p><p>Note that the <code>ret</code> and <code>tOp</code> are also overwritten. <code>BCH_Transform(nOmega,H0,IMSRGObj,tmpOp,norms,Chan2b)</code> e.g., <code>Omega</code>: <span>$\Omega(s+ds)$</span>, <code>H0</code>: <span>$H(s=0)$</span> or <span>$O(s=0)$</span>, and <code>ret</code>: <span>$H(s+ds)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L85-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.OpCommutator!-Union{Tuple{Op}, Tuple{Op, Op, Op, Any, Any, Any, Any, Any, Any, Any}} where Op&lt;:NuclearToolkit.Operator" href="#NuclearToolkit.OpCommutator!-Union{Tuple{Op}, Tuple{Op, Op, Op, Any, Any, Any, Any, Any, Any, Any}} where Op&lt;:NuclearToolkit.Operator"><code>NuclearToolkit.OpCommutator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OpCommutator!(X::Op,Y::Op,ret::Op,HFobj,Chan1b,Chan2bD,dictMono,dict6j,PandyaObj,to) where{Op &lt;: Operator}</code></pre><p>overwrite ret operator by <span>$[X,Y]$</span> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.calcZbar!-NTuple{11, Any}" href="#NuclearToolkit.calcZbar!-NTuple{11, Any}"><code>NuclearToolkit.calcZbar!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcZbar!(Xbar,Ybar,PhaseMat,PhaseMatY,tmpMat,hy,nph_kets,nKets_cc,Zlefthalf,Zrighthalf,hz)

`Xbar`: (`nKets_cc`, 2*`nph_kets`)</code></pre><p><code>Ybar</code>: (2<em><code>nph_kets</code>,<code>nKets_cc</code>) <code>PhaseMatY</code>: (<code>nph_kets</code>,<code>nKets_cc</code>) <code>Zbar</code>: (<code>nKets_cc</code>, 2</em><code>nKets_cc</code>)</p><pre><code class="nohighlight hljs">                | nph_kets,nKets_cc</code></pre><p>(nKets<em>cc,nKets</em>cc) |––––––                     | nph<em>kets,nKets</em>cc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L606-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.comm111ss!-Tuple{Any, Any, Any}" href="#NuclearToolkit.comm111ss!-Tuple{Any, Any, Any}"><code>NuclearToolkit.comm111ss!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">comm111ss!(X,Y,ret;inifac=1.0)</code></pre><p><span>$[X_1,Y_1]$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.comm121ss!-NTuple{8, Any}" href="#NuclearToolkit.comm121ss!-NTuple{8, Any}"><code>NuclearToolkit.comm121ss!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">comm121ss!(X,Y,ret,HFobj,Chan1b,Chan2b,dictMono,PandyaObj)</code></pre><p>returns <span>$[X_1,Y_2] - [Y_1,X_2]$</span>, whose elements are given as </p><p><span>$[X_1,Y_2]_{ij} = \frac{1}{2j_i+1}\sum_{ab} (n_a \bar{n}_b) \sum_{J} (2J+1) (X_{ab} Y^J_{biaj} - X_{ba} Y^J_{aibj})$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.comm220ss!-Union{Tuple{zerobody}, Tuple{Any, Any, zerobody, Any, Any}} where zerobody&lt;:Vector{Float64}" href="#NuclearToolkit.comm220ss!-Union{Tuple{zerobody}, Tuple{Any, Any, zerobody, Any, Any}} where zerobody&lt;:Vector{Float64}"><code>NuclearToolkit.comm220ss!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">comm220ss!(X,Y,Z::zerobody,HFobj,Chan2b) where {zerobody&lt;:Vector{Float64}}</code></pre><p><span>$[X_2,Y_2]_0 = 2 \sum_{J}(2J+1) \mathrm{Tr}(X_{hh&#39;pp&#39;}  Y_{pp&#39;hh&#39;})$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.comm221ss!-NTuple{7, Any}" href="#NuclearToolkit.comm221ss!-NTuple{7, Any}"><code>NuclearToolkit.comm221ss!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">comm221ss!(X,Y,ret,HFobj,Chan1b,Chan2bD,PandyaObj)</code></pre><p>returns <span>$[X_2,Y_2]_1 - [Y_2,X_2]_1$</span>, whose elements are given as</p><p><span>$[X_2,Y_2]_{ij} = 1/(2[j_i]) \sum_{abc}\sum_{J}[J](n&#39;_an&#39;_bn_c-n_an_bn&#39;_c)(X_{2,ciab}Y_{2,abcj}-Y_{2,ciab}X_{2,abcj})$</span></p><p>Note that our code gives diffrent results from the IMSRG code by S.R.Stroberg here. If you replace <code>sqfac_ab^2</code> in this function by 2.0, the results agree with each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L330-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.single_121-NTuple{9, Any}" href="#NuclearToolkit.single_121-NTuple{9, Any}"><code>NuclearToolkit.single_121</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">single_121(a,b,i,j,o1b,o2bs,sps,key,targetDict;verbose=false)</code></pre><p>calc 121part <span>$[X_1,Y_2]-[Y_1,X_2]$</span> for given <code>i</code>,<code>j</code> and <code>a</code>,<code>b</code>.</p><p><span>$\sum_{J} [J]^2 (o1_{ab}o2_{biaj} - o1_{ba}o2_{aibj})$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/commutator.jl#L270-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.DoPandyaTransformation_SingleChannel" href="#NuclearToolkit.DoPandyaTransformation_SingleChannel"><code>NuclearToolkit.DoPandyaTransformation_SingleChannel</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function to carry out Pandya transformation:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L437-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.GatherOmega-NTuple{18, Any}" href="#NuclearToolkit.GatherOmega-NTuple{18, Any}"><code>NuclearToolkit.GatherOmega</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GatherOmega(Omega,nOmega,gatherer,tmpOp,Nested,H0,Hs,ncomm,norms,Chan1b,Chan2bD,HFobj,IMSRGobj,dictMono,dict6j,PandyaObj,maxnormOmega,to)</code></pre><p>This may not be used now.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L792-L796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Get2bDenominator-NTuple{14, Any}" href="#NuclearToolkit.Get2bDenominator-NTuple{14, Any}"><code>NuclearToolkit.Get2bDenominator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Get2bDenominator(ch,pnrank,a,b,i,j,na,nb,ni,nj,f,Delta,dictMono,key;verbose=false)</code></pre><p><span>$f_{aa} +f_{bb} −f_{ii} −f_{jj} +G_{abij} +\Delta$</span></p><p>with <span>$G_{abij} = \Gamma_{abab} + \Gamma_{ijij} - (\Gamma_{aiai} + \Gamma_{bjbj} + [a \leftrightarrow b])$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L262-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.Gethhph-Tuple{Any, Any}" href="#NuclearToolkit.Gethhph-Tuple{Any, Any}"><code>NuclearToolkit.Gethhph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gethhph(kets,sps)</code></pre><p>get idxs for hh/ph kets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L827-L831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.adhoc_rewrite6jdict" href="#NuclearToolkit.adhoc_rewrite6jdict"><code>NuclearToolkit.adhoc_rewrite6jdict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adhoc_rewrite6jdict(emax,dict6j,ofst_unit=1000)</code></pre><p>adhoc function to replace dict. for 6j-symbols:{ji,jj,J,jk,jl,J&#39;} key = [ji,jj,jk,jl,J&#39;] -&gt; new<em>key::Int64 new</em>dict is Vector for total J</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L579-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.calc_Eta_atan!-NTuple{5, Any}" href="#NuclearToolkit.calc_Eta_atan!-NTuple{5, Any}"><code>NuclearToolkit.calc_Eta_atan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_Eta_atan!(HFobj,IMSRGobj,Chan2b,dictMono,norms)</code></pre><p>calc. <span>$\eta(s)$</span> with atan generator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.check_order_Mkey-Tuple{Any, Any}" href="#NuclearToolkit.check_order_Mkey-Tuple{Any, Any}"><code>NuclearToolkit.check_order_Mkey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_order_Mkey(key,pnrank)</code></pre><p>reorder key to be <code>key[1] &gt; key[2]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.flow_Operators-NTuple{12, Any}" href="#NuclearToolkit.flow_Operators-NTuple{12, Any}"><code>NuclearToolkit.flow_Operators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flow_Operators(binfo,HFobj,IMSRGobj,PandyaObj,Chan1b,Chan2bD,dict_9j,HOBs,dictMono,dict6j,Operators,to)</code></pre><p>consistent IMSRG flow of scaler operators (Rp2) using written Omega</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L918-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.generator_atan-NTuple{6, Any}" href="#NuclearToolkit.generator_atan-NTuple{6, Any}"><code>NuclearToolkit.generator_atan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>generator<em>atan     a: particle index     i: hole index     Gam: D&#39;NO2B     iket:: index for |ai&gt; to get Gam</em>{aiai}=Gam[iket,iket]     Delta: parameter for energy shift like EKK</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L885-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.getNorm-NTuple{4, Any}" href="#NuclearToolkit.getNorm-NTuple{4, Any}"><code>NuclearToolkit.getNorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNorm(O,p_sps,n_sps,Chan2b)</code></pre><p>returns sqrt(norm1b^2 + norm2b^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.getNorm1b" href="#NuclearToolkit.getNorm1b"><code>NuclearToolkit.getNorm1b</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getNorm1b(Mat1b,p_sps,n_sps,verbose=false)</code></pre><p>returns 1bnorm of the given Operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.getNorm2b" href="#NuclearToolkit.getNorm2b"><code>NuclearToolkit.getNorm2b</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getNorm2b(Mat2b,Chan2b,verbose=false)</code></pre><p>returns 2bnorm of the given Operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.imsrg_main-NTuple{11, Any}" href="#NuclearToolkit.imsrg_main-NTuple{11, Any}"><code>NuclearToolkit.imsrg_main</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imsrg_main(binfo,Chan1b,Chan2bD,HFobj,dictMono,d9j,HOBs,dict6j,valencespace,Operators,to; core_generator_type=&quot;atan&quot;,valence_generator_type=&quot;shell-model-atan&quot;,denominatorDelta=0.0)</code></pre><p><strong>Arguments</strong></p><ul><li><code>binfo::basedat</code> struct basedat(nuc::nuclei,sntf::String,hw::Float,emax::Int)</li><li><code>Chan1b::chan1b</code> struct for one-body stuffs</li><li><code>Chan2bD::chan2bD</code> struct for two-body stuffs (e.g., dict to get idx from JPT)</li><li><code>HFobj::HamiltonianNormalOrdered</code> struct HNO, which includes info. of HF solution (HF energy, occupation, f,Gamma,...)</li><li><code>dictMono::Dict</code> dictionary to get Vmonopole</li><li><code>d9j</code> preallocated dictionaries for wigner 9j symbols, which are needed to calculate Rp2</li><li><code>HOBs</code> struct HarmonicOscillatorBrackets </li><li><code>dict6j</code> preallocated dictionaries for wigner6j symbols (needed in e.g., Pandya transformation)</li><li><code>valencespace</code> to specify valence space  </li><li><code>Operators::Vector{String}</code> non-Hamiltonian operators</li><li><code>to</code> TimerOutput object to measure runtime&amp;memory allocations</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>core_generator_type</code> only the &quot;atan&quot; is implemented</li><li><code>valence_generator_type</code> only the &quot;shell-model-atan&quot; is implemented</li><li><code>denominatorDelta::Float</code> denominator Delta, which is needed for multi-major shell decoupling</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.init_IMSRGobject-Tuple{Any}" href="#NuclearToolkit.init_IMSRGobject-Tuple{Any}"><code>NuclearToolkit.init_IMSRGobject</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_IMSRGobject(HFobj;smax=500.0,dsmax=0.5,maxnormOmega=0.25,tol=1.e-6,eta_criterion=1.e-6,denominatorDelta=0.0)</code></pre><p>Constructor for IMSRGobject</p><ul><li><code>H0::Operator</code> for starting point of BCH product</li><li><code>H::Operator</code> Hamiltonian <span>$H(s)$</span></li><li><code>s::Vector{Float}</code> current <span>$s$</span> and <span>$ds$</span></li><li><code>smax::Float</code> maximum <span>$s$</span></li><li><code>dsmax::Float</code> maximum <span>$ds$</span></li><li><code>maxnormOmega::Float</code> maximum ||Omega||</li><li><code>eta::Operator</code> generator of IMSRG flow (antihermite Operator)</li><li><code>Omega::Operator</code> generator of IMSRG flow (antihermite Operator) </li><li><code>eta_criterion::Float</code> ||eta|| to check convergence</li><li><code>denominatorDelta::Float64</code> parameter for multi-major shell decoupling</li><li><code>n_written_omega::Int</code> # of written Omega by splitting to solve IMSRGflow</li><li><code>Ncomm::Vector{Int}</code> # of commutator evaluated during IMSRG flow</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L842-L858">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.init_dictMonopole!-Tuple{Any, Any}" href="#NuclearToolkit.init_dictMonopole!-Tuple{Any, Any}"><code>NuclearToolkit.init_dictMonopole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_dictMonopole!(dictMonopole,Chan2b)</code></pre><p>initialize <code>dictMonopole</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.make_PandyaKets-Tuple{Any, Any}" href="#NuclearToolkit.make_PandyaKets-Tuple{Any, Any}"><code>NuclearToolkit.make_PandyaKets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_PandyaKets(emax,HFobj)</code></pre><p>To prepare &quot;kets&quot; for Pandya transformation. For ordinary two-body channels, kets like <code>|i,j=i;J=odd&gt;</code> where <code>i={n,l,j,tz}</code> are hindered, but necessary for Pandya transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.prep_PandyaLookup-NTuple{4, Any}" href="#NuclearToolkit.prep_PandyaLookup-NTuple{4, Any}"><code>NuclearToolkit.prep_PandyaLookup</code></a> — <span class="docstring-category">Method</span></header><section><div><p>numbers<em>Pandya:[ch,nKet</em>cc,nhh,nph] for ich (channel index of Chan2b_Pandya) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L369-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.print_flowstatus-NTuple{5, Any}" href="#NuclearToolkit.print_flowstatus-NTuple{5, Any}"><code>NuclearToolkit.print_flowstatus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_flowstatus(istep,s,ncomm,norms,IMSRGobj)</code></pre><p>print flowstatus s,E0,1b&amp;2b norm for Omega, 1b&amp;2b norm for Eta, Ncomm, nwritten</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.read_imsrg_parameter!-Tuple{Any, Any}" href="#NuclearToolkit.read_imsrg_parameter!-Tuple{Any, Any}"><code>NuclearToolkit.read_imsrg_parameter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_imsrg_parameter!(fn,IMSRGobj)</code></pre><p>Function to overwrite IMSRGobj from the parameter file <code>fn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L58-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.read_omega_bin!" href="#NuclearToolkit.read_omega_bin!"><code>NuclearToolkit.read_omega_bin!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_omega_bin!(nw,Op,verbose=false)</code></pre><p>read written Omega file and update <code>Op::Operator</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L751-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.set_dictMonopole!-Tuple{Any, Any, Any}" href="#NuclearToolkit.set_dictMonopole!-Tuple{Any, Any, Any}"><code>NuclearToolkit.set_dictMonopole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_dictMonopole!(dictMonopole,HFobj,H)</code></pre><p>To update dictMonopole pp/pn/nn under H(s=0)/IMSRG H(s)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.set_sps_to_core!-Tuple{Any, Any}" href="#NuclearToolkit.set_sps_to_core!-Tuple{Any, Any}"><code>NuclearToolkit.set_sps_to_core!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_sps_to_core!(binfo,HFobj)</code></pre><p>modify <code>p_sps.occ, n_sps.occ</code> by the &quot;core&quot; nucleus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L966-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.set_sps_to_modelspace!-Tuple{Any, Any}" href="#NuclearToolkit.set_sps_to_modelspace!-Tuple{Any, Any}"><code>NuclearToolkit.set_sps_to_modelspace!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_sps_to_modelspace!(binfo,HFobj)</code></pre><p>modify occupation by specified model space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L992-L996">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.update_core_in_sps!-Tuple{Any, Any}" href="#NuclearToolkit.update_core_in_sps!-Tuple{Any, Any}"><code>NuclearToolkit.update_core_in_sps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_core_in_sps!(binfo,HFobj)</code></pre><p>Function to specify hole/core for sps. This will will be used for target normal ordering</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L938-L942">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.write_omega_bin-Tuple{Any, Any, Any}" href="#NuclearToolkit.write_omega_bin-Tuple{Any, Any, Any}"><code>NuclearToolkit.write_omega_bin</code></a> — <span class="docstring-category">Method</span></header><section><div><p>to write binary file for Operator flow using split/huntergatherer method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/imsrg_util.jl#L702-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.calc_Eta_smatan!-NTuple{5, Any}" href="#NuclearToolkit.calc_Eta_smatan!-NTuple{5, Any}"><code>NuclearToolkit.calc_Eta_smatan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_Eta_smatan!(HFobj,IMSRGobj,Chan2b,dictMono,norms)</code></pre><p><span>$\eta(s)$</span> with shell-model atan generator to decouple valence space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/valencespace.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.check_major_valencespace-Tuple{String, Any, Any}" href="#NuclearToolkit.check_major_valencespace-Tuple{String, Any, Any}"><code>NuclearToolkit.check_major_valencespace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_major_valencespace(str::String,HFobj,v)</code></pre><p>Function to check valence space and overwrite <code>v</code> and <code>q</code> fields of SingleParticleState The valencespace is specified by argument <code>str</code> (e.g. &quot;p-shell&quot;) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/valencespace.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.check_str_valencespace-Tuple{Vector{Vector{Int64}}, Any, Any}" href="#NuclearToolkit.check_str_valencespace-Tuple{Vector{Vector{Int64}}, Any, Any}"><code>NuclearToolkit.check_str_valencespace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_str_valencespace(valencespace::Vector{Vector{Int64}},HFobj,v)</code></pre><p>check valence space and overwrtie SingleParticleState.v/q</p><p>specified by or Vector{Int} (e.g., [[0,1,1,-1],[0,1,3,-1], [0,1,1,1],[0,1,3,1]])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/valencespace.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.check_valence_space-Tuple{Any, Any}" href="#NuclearToolkit.check_valence_space-Tuple{Any, Any}"><code>NuclearToolkit.check_valence_space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_valence_space(HFobj,valencespace)</code></pre><p>check validity of specified valence space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/valencespace.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.update_vsspace_chs!-Tuple{Any, Any, Any}" href="#NuclearToolkit.update_vsspace_chs!-Tuple{Any, Any, Any}"><code>NuclearToolkit.update_vsspace_chs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_vsspace_chs!(HFobj,valencespace,Chan2b)</code></pre><p>overwrite cc/vc/qc/vv/qv/qq channals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/valencespace.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NuclearToolkit.write_vs_snt-NTuple{8, Any}" href="#NuclearToolkit.write_vs_snt-NTuple{8, Any}"><code>NuclearToolkit.write_vs_snt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_vs_snt(binfo,HFobj,IMSRGobj,Operators,effOps,Chan1b,Chan2bD,vspace)</code></pre><p>Function to write out valence space effective interaction in snt (KSHELL/ShellModel.jl) format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SotaYoshida/NuclearToolkit.jl/blob/2b5b90887fad64549ed6eb33e1a03fde6270cf58/src/IMSRG.jl/valencespace.jl#L220-L224">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="HartreeFock.html">« HartreeFock</a><a class="docs-footer-nextpage" href="ShellModel.html">ShellModel »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Monday 23 May 2022 09:58">Monday 23 May 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
