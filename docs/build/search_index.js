var documenterSearchIndex = {"docs":
[{"location":"ChiEFTint.html#ChiEFTint","page":"ChiEFTint","title":"ChiEFTint","text":"","category":"section"},{"location":"ChiEFTint.html","page":"ChiEFTint","title":"ChiEFTint","text":"Functions needed to generate nucleon-nucleon (NN) potential from Chiral EFT.","category":"page"},{"location":"ChiEFTint.html","page":"ChiEFTint","title":"ChiEFTint","text":"The parameters needed for chiEFTint are specified in optional_parameters.jl. If you want to change Low-energy constatants, edit the LECs.jl or use dictionary for LECs e.g., in main_chiEFTint.jl.","category":"page"},{"location":"ChiEFTint.html","page":"ChiEFTint","title":"ChiEFTint","text":"Modules = [NuclearToolkit]\nPages = [\"chiEFTint/main_chiEFTint.jl\",\n         \"chiEFTint/contact.jl\",\n         \"chiEFTint/pionexchange.jl\",\n         \"chiEFTint/angmom_algebra.jl\",\n         \"chiEFTint/misc_plt_io.jl\",\n         \"chiEFTint/threebodyforce.jl\",\n         \"chiEFTint/bayesopt.jl\",\n         \"chiEFTint/valence.jl\",         \n         \"chiEFTint/eff3nf.jl\",\n]","category":"page"},{"location":"ChiEFTint.html#NuclearToolkit.Gauss_Legendre-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.Gauss_Legendre","text":"Gauss_Legendre(xmin,xmax,n;eps=3.e-16)\n\nto calculate mesh points and weights for Gauss-Legendre quadrature\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.QL-Tuple{Any, Int64, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.QL","text":"QL(z,J::Int64,ts,ws)\n\nTo calculate Legendre functions of second kind by Gauss-Legendre quadrature\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.RKstep-NTuple{7, Any}","page":"ChiEFTint","title":"NuclearToolkit.RKstep","text":"RKstep(T,Ho,eta,R,faceta,fRK,Ht)\n\nwrapper function to calc. a Runge-Kutta (RK) step\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.Rnl_all_ab-NTuple{5, Any}","page":"ChiEFTint","title":"NuclearToolkit.Rnl_all_ab","text":"Rnl_all_ab(lmax,br,n_mesh,xr_fm)\n\nReturns array for radiul functions (prop to generalized Laguerre polynomials) HO w.f. in momentum space. Rnlk(l,n,k)=sqrt(br) * R(n,L,Z) Z with Z=brk (k=momentum in fm^-1)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.SRG-NTuple{6, Any}","page":"ChiEFTint","title":"NuclearToolkit.SRG","text":"SRG(xr,wr,V12mom,dict_numst,to)\n\nmain function for Similarity Renormalization Group (SRG) transformation of NN interaction in CM-rel momentum space.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.calc_Vmom!-NTuple{14, Any}","page":"ChiEFTint","title":"NuclearToolkit.calc_Vmom!","text":"calc_Vmom!(pnrank,V12mom,tdict,xr,LEC,LEC2,l,lp,S,J,pfunc,n_reg,to;is_3nf=false)\n\ncalc. nn-potential for momentum mesh points\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.commutator-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.commutator","text":"commutator(A,B,R,fac)\n\nwrapper function to overwrite R by fac*(AB-BA)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.hw_formula-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.hw_formula","text":"hw_formula(A,fnum)\n\nempirical formula for harmonis oscillator parameter hw by mass number A fnum=2: for sd-shell, Ref. J. Blomqvist and A. Molinari, Nucl. Phys. A106, 545 (1968).\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.make_chiEFTint-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.make_chiEFTint","text":"make_chiEFTint(;is_plot=false,BO=false,optHFMBPT=false,itnum=20,writesnt=true,nucs=[])\n\nmain function in chiEFTint. This generates NN-potential in momentum space and then transforms it in HO basis. This function is exported and can be simply called make_chiEFTint() in the run script. \n\nOptional arguments: Note that these are mainly for the author's purposes, so you do not specify these.\n\noptHFMBPT::Bool to optimize LECs using BO&HFMBPT\nitnum::Int=20 number of iteration for BO&HFMBPT\nis_plot::Bool, to visualize optimization process of LECs\nwritesnt::Bool, to write out interaction file in snt (KSHELL) format. julia writesnt = false case can be usefull when you repeat large number of calculations for different LECs.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.read_LECs!-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.read_LECs!","text":"read_LECs!(LECs,idxLECs,dLECs;initialize=false,inpf=\"src/chiEFTint/LECs.jl\")\n\nread LECs from \"src/chiEFTint/LECs.jl\" (default) and  store them as LECs(Vector{Float}), idxLECs(Vector{Int}), and dLECs(Dict{str,Float}).\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.srg_tr-NTuple{11, Any}","page":"ChiEFTint","title":"NuclearToolkit.srg_tr","text":"srg_tr(Ho,T,Ht,Hs,eta,R,sSRG,face,ds,numit,to; r_err=1.e-8,a_err=1.e-8,tol=1.e-6)\n\nto carry out SRG transformation\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.OPEP-NTuple{11, Any}","page":"ChiEFTint","title":"NuclearToolkit.OPEP","text":"OPEP(ts,ws,xr,V12mom,dict_numst,to,lsjs,llpSJ_s,tllsj,opfs;pigamma=true)\n\ncalc. One-pion exchange potential\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.single_tpe-NTuple{39, Any}","page":"ChiEFTint","title":"NuclearToolkit.single_tpe","text":"single_tpe(nd_mpi,nd_mpi2,nd_mpi4,nd_mpi6,nd_mpi8,Fpi2,Fpi4,Fpi6,c1,c2,c3,c4,r_d12,r_d3,r_d5,r_d145,J,pnrank,ts,ws,xdwn,ydwn,xdwn2,ydwn2,k2,pjs,gis,opfs,fc,f_idx,tVs,lsj,tllsj,tdict,V12mom,V_i,V_j,to)\n\nTPE contribution in a given momentum mesh point\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.tpe-NTuple{12, Any}","page":"ChiEFTint","title":"NuclearToolkit.tpe","text":"tpe(LECs,ts,ws,xr,V12mom,dict_numst,to,llpSJ_s,lsjs,tllsj,opfs)\n\ncalc. two-pion exchange terms up to N3LO\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.CGm0-Tuple{Any, Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.CGm0","text":"CGm0(l1,l2,l)\n\nCG coefficients for special case (l1,m1=0,l2,m2=0|l,m=0)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.HObracket-NTuple{9, Any}","page":"ChiEFTint","title":"NuclearToolkit.HObracket","text":"HObracket(n1,l1,n2,l2,n,l,N,L,Lam;d=1)\n\nTo calc. harmonic oscillator brackets, <EL,el:Lam|e1l1,e2l2:Lam>d. The phase (-1)^(N+n+n1+n2) is needed to reproduce Tab.1 of [1]. This function has large overlap to other functions (gmosh, etc.), so it will be merged in near future...\n\nReference:\n\n[1] B.Buck& A.C.merchant, Nucl.Phys. A600 (1996) 387-402\n\n[2] G.P.Kamuntavicius et al., Nucl.Phys. A695 (2001) 191-201\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.PreCalc6j-Tuple{Any}","page":"ChiEFTint","title":"NuclearToolkit.PreCalc6j","text":"PreCalc6j(emax)\n\npreallocate 6j used for HF\n\nbeginBmatrix \nj_a  j_b  J \nj_c  j_d  J\nendBmatrix\n\njajbjcjd are half-integer extended for kinetic_tb\n\nbeginBmatrix \nj_12  j_22     1 \n  l_2    l_1   12\nendBmatrix\n\nare needed to get dict6j[J][key] with key = [ja,jb,jd,jc,Jp]. Using array as key is in general slow, so the key is transformed into integer in the IMSRG part (But, this sometimes reduces readability...)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.PreCalcHOB-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.PreCalcHOB","text":"PreCalcHOB(chiEFTobj,to)\n\nsee also \"struct HarmonicOscillatorBrackets\" in hartreefock.jl/def_struct.jl\n\nIn the early version, dict9j is defined as dict9j = [ [ Dict{Vector{Int64},Float64}() for S=0:1 ] for J=0:Jmax] with key~[la,ja,lb,jb,L] Dict using array as key is slow, so this was fixed to... dict9j => nested array J=>S=>L=>ja=>la=>jb=>lb Note that div(j,2)+1 will be used as idx for ja&jb.\n\nThe same can be said for HOBs HOBs => nested array N=>n=>Lam=>lam=>L=>na=>nb=>la (lb is automatically determined)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.TMtrans-NTuple{19, Any}","page":"ChiEFTint","title":"NuclearToolkit.TMtrans","text":"TMtrans(dLECs,xr,wr,xrP,wrP,Rnl,RNL,nTBME,infos,izs_ab,Numpn,V12ab,arr_numst,dict6j,d6j_nabla,X9,U6,to;calc_relcm=false,writesnt=true)\n\nFunction to carry out Talmi-Mochinsky transformation\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.kinetic_ob-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.kinetic_ob","text":"kinetic_ob(nlj1, nlj2)\n\ncalc. kinetic one-body contribution\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.kinetic_tb-NTuple{8, Any}","page":"ChiEFTint","title":"NuclearToolkit.kinetic_tb","text":"kinetic_tb(nljtz1, nljtz2, nljtz3, nljtz4,J, dict6j,d6j_nabla,key6j)\n\ncalc. kinetic two-body contribution using preallocated 6j Dict\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.prep_wsyms-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.prep_wsyms","text":"prep_wsyms()\n\ncg1s = (1,0,l,0|l',0), cg2s = (2,0,l,0|l',0)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.prepareX9U6-Tuple{Any}","page":"ChiEFTint","title":"NuclearToolkit.prepareX9U6","text":"prepareX9U6(Nrmax;to=nothing)\n\nreturn 6j/9j dict: for 6j => jj->S->lam->lc->lr, for 9j => S->J->key= [la,nja,lb,njb,lam]\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.readsnt-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.readsnt","text":"readsnt(sntf,Anum;eachA=false,pnfac=1.0)\n\nto read sntfile. This is slightly different from readsnt() in ShellModel.jl\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.s_wigner9j-NTuple{7, Any}","page":"ChiEFTint","title":"NuclearToolkit.s_wigner9j","text":"s_wigner9j(j1,j3,j4,j6,j7,j8,j9)\n\nto calc. wigner9j for specific cases with j2=j5=1/2\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.wigner9j-NTuple{9, Any}","page":"ChiEFTint","title":"NuclearToolkit.wigner9j","text":"wigner9j(j1,j2,j3,j4,j5,j6,j7,j8,j9)\n\ncalculate Wigner 9j symbols, all j should be given as integer (0,1,...) or halfinteger (3/2, 3//2,...)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.chiEFTparams","page":"ChiEFTint","title":"NuclearToolkit.chiEFTparams","text":"chiEFTparams\n\nmutable struct to specify parameters for chiEFTint\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"ChiEFTint.html#NuclearToolkit.init_chiEFTparams-Tuple{}","page":"ChiEFTint","title":"NuclearToolkit.init_chiEFTparams","text":"init_chiEFTparams(;fn_params=\"optional_parameters.jl\")\n\nconstructor of chiEFTparams, see chiEFTparams mutable struct for more details.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.momplot-NTuple{5, Any}","page":"ChiEFTint","title":"NuclearToolkit.momplot","text":"momplot(xr,V12mom,tdict,pnrank,llpSJ_s;ctext=\"\",fpath=\"\")\n\nplot nn potential in partial wave over relative momentum space\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.print_vec-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.print_vec","text":"print_vec(s,v;ine=false)\n\nfunction to make println(stdout) more readable. This is usuful for debug.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.pw_plt-NTuple{5, Any}","page":"ChiEFTint","title":"NuclearToolkit.pw_plt","text":"pw_plt(tx,xr,z,zds,pnrank;fdat=[])\n\nfdat: normally no need to specify. optional array to specify text file for cross check\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.read_chiEFT_parameter!-Tuple{Any, NuclearToolkit.chiEFTparams}","page":"ChiEFTint","title":"NuclearToolkit.read_chiEFT_parameter!","text":"read_chiEFT_parameter!(fn,params)\n\nFunction to overwrite params from the parameter file fn.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.write_tbme-NTuple{12, Any}","page":"ChiEFTint","title":"NuclearToolkit.write_tbme","text":"write_tbme(chiEFTobj,io,ndim,izs,Jtot,vv,nljsnt,nljdict,tkeys,dict6j,d6j_nabla,key6j;ofst=0)\n\nwrite tbme in myg/snt(snt.bin) format\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.write_vmom-NTuple{5, Any}","page":"ChiEFTint","title":"NuclearToolkit.write_vmom","text":"write_vmom(xr,V12mom,tdict,pnrank,llpSJ_s;label=\"\")\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.anti_op_isospin-NTuple{20, Any}","page":"ChiEFTint","title":"NuclearToolkit.anti_op_isospin","text":"anti_op_isospin(dWS,n12,l12,s12,j12,t12,n3,l3,j3,n45,l45,s45,j45,t45,n6,l6,j6,jtot,ttot,to)\n\nFunction to calc. matrix element of antisymmetrizer.   Detailed derivation can be found in e.g., Eq.(3.119) of Master Thesis by Joachim Langhammer (2010), TUDarmstadt.\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.overwrite_key6!-NTuple{4, Any}","page":"ChiEFTint","title":"NuclearToolkit.overwrite_key6!","text":"overwrite_key6!(s12,S,s45,key)\n\noverwrite key for 6j symbols\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.overwrite_key9!-NTuple{9, Any}","page":"ChiEFTint","title":"NuclearToolkit.overwrite_key9!","text":"overwrite_key9!(l12,s12,j12,l3,j3,Lam,stot,jtot,key)\n\noverwrite key for 9j symbols\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.prep_dWS3n-Tuple{Any, Any}","page":"ChiEFTint","title":"NuclearToolkit.prep_dWS3n","text":"prep_dWS3n(e3max,N3max)\n\nto prepare Wigner symbols (CG/6j/9j) for three body force\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.calc_GPllh-Tuple{Any}","page":"ChiEFTint","title":"NuclearToolkit.calc_GPllh","text":"-0.5 y^TKtt^{-1}y - logdet(Kw)\n\n\n\n\n\n","category":"method"},{"location":"ChiEFTint.html#NuclearToolkit.XF-Tuple{Any}","page":"ChiEFTint","title":"NuclearToolkit.XF","text":"Refs.:\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#IMSRG","page":"IMSRG","title":"IMSRG","text":"","category":"section"},{"location":"IMSRG.html","page":"IMSRG","title":"IMSRG","text":"Functions for IM-SRG calculations","category":"page"},{"location":"IMSRG.html","page":"IMSRG","title":"IMSRG","text":"imsrg_util.jl: contains main and util functions \ncommutator.jl: functions to calculate commutators and BCH transform to carry out IMSRG flow with Magnus expansion\nvalencespace.jl: functions for Valence-space IM-SRG (VS-IMSRG) calculations to derive shell-model effective interactions/operators","category":"page"},{"location":"IMSRG.html","page":"IMSRG","title":"IMSRG","text":"Modules = [NuclearToolkit]\nPages = [\"IMSRG.jl/commutator.jl\",\n         \"IMSRG.jl/imsrg_util.jl\",\n         \"IMSRG.jl/valencespace.jl\"]","category":"page"},{"location":"IMSRG.html#NuclearToolkit.BCH_Product-NTuple{14, Any}","page":"IMSRG","title":"NuclearToolkit.BCH_Product","text":"BCH_Product(X,Y,Z,tmpOp,Nested,ncomm,norms,Chan1b,Chan2bD,HFobj,dictMono,dict6j,PandyaObj,to;tol=1.e-4)\n\nreturns Z  to satisfy: e^Z = e^X e^Y  \n\nZ is calculated with Baker–Campbell–Hausdorff (BCH) formula:\n\nZ = X + Y + 12X Y  + 112 XXY + 112 YYX -124 YXXY -1720 YYYYX -1720 XXXXY +\n\nFor IMSRG flow of H(s), X=eta(s)*ds, Y=Omega(s), and Z=Omega(s+ds) \n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.BCH_Transform-NTuple{14, Any}","page":"IMSRG","title":"NuclearToolkit.BCH_Transform","text":"BCH_Transform(Omega,O0,Hs,tOp,Nested,ncomm,norms,Chan1b,Chan2bD,HFobj,dictMono,dict6j,PandyaObj,to;tol=1.e-9,maxit=50,verbose=false)\n\nUpdate B (assumed to be H or O) via e^ABe^-A =B+AB+12AAB+13AAAB+\n\nIt needs 3 copy to store (k-1)-th adj./k-th adj./ret.\n\nNote that the ret and tOp are also overwritten. BCH_Transform(nOmega,H0,IMSRGObj,tmpOp,norms,Chan2b) e.g., Omega: Omega(s+ds), H0: H(s=0) or O(s=0), and ret: H(s+ds)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.OpCommutator!-Union{Tuple{Op}, Tuple{Op, Op, Op, Any, Any, Any, Any, Any, Any, Any}} where Op<:NuclearToolkit.Operator","page":"IMSRG","title":"NuclearToolkit.OpCommutator!","text":"OpCommutator!(X::Op,Y::Op,ret::Op,HFobj,Chan1b,Chan2bD,dictMono,dict6j,PandyaObj,to) where{Op <: Operator}\n\noverwrite ret operator by XY \n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.calcZbar!-NTuple{11, Any}","page":"IMSRG","title":"NuclearToolkit.calcZbar!","text":"calcZbar!(Xbar,Ybar,PhaseMat,PhaseMatY,tmpMat,hy,nph_kets,nKets_cc,Zlefthalf,Zrighthalf,hz)\n\n`Xbar`: (`nKets_cc`, 2*`nph_kets`)\n\nYbar: (2nph_kets,nKets_cc) PhaseMatY: (nph_kets,nKets_cc) Zbar: (nKets_cc, 2nKets_cc)\n\n                | nph_kets,nKets_cc\n\n(nKetscc,nKetscc) |––––––                     | nphkets,nKetscc\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.comm111ss!-Tuple{Any, Any, Any}","page":"IMSRG","title":"NuclearToolkit.comm111ss!","text":"comm111ss!(X,Y,ret;inifac=1.0)\n\nX_1Y_1\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.comm121ss!-NTuple{8, Any}","page":"IMSRG","title":"NuclearToolkit.comm121ss!","text":"comm121ss!(X,Y,ret,HFobj,Chan1b,Chan2b,dictMono,PandyaObj)\n\nreturns X_1Y_2 - Y_1X_2, whose elements are given as \n\nX_1Y_2_ij = frac12j_i+1sum_ab (n_a barn_b) sum_J (2J+1) (X_ab Y^J_biaj - X_ba Y^J_aibj)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.comm220ss!-Union{Tuple{zerobody}, Tuple{Any, Any, zerobody, Any, Any}} where zerobody<:Vector{Float64}","page":"IMSRG","title":"NuclearToolkit.comm220ss!","text":"comm220ss!(X,Y,Z::zerobody,HFobj,Chan2b) where {zerobody<:Vector{Float64}}\n\nX_2Y_2_0 = 2 sum_J(2J+1) mathrmTr(X_hhpp  Y_pphh)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.comm221ss!-NTuple{7, Any}","page":"IMSRG","title":"NuclearToolkit.comm221ss!","text":"comm221ss!(X,Y,ret,HFobj,Chan1b,Chan2bD,PandyaObj)\n\nreturns X_2Y_2_1 - Y_2X_2_1, whose elements are given as\n\nX_2Y_2_ij = 1(2j_i) sum_abcsum_JJ(n_an_bn_c-n_an_bn_c)(X_2ciabY_2abcj-Y_2ciabX_2abcj)\n\nNote that our code gives diffrent results from the IMSRG code by S.R.Stroberg here. If you replace sqfac_ab^2 in this function by 2.0, the results agree with each other.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.single_121-NTuple{9, Any}","page":"IMSRG","title":"NuclearToolkit.single_121","text":"single_121(a,b,i,j,o1b,o2bs,sps,key,targetDict;verbose=false)\n\ncalc 121part X_1Y_2-Y_1X_2 for given i,j and a,b.\n\nsum_J J^2 (o1_abo2_biaj - o1_bao2_aibj)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.DoPandyaTransformation_SingleChannel","page":"IMSRG","title":"NuclearToolkit.DoPandyaTransformation_SingleChannel","text":"function to carry out Pandya transformation:\n\n\n\n\n\n","category":"function"},{"location":"IMSRG.html#NuclearToolkit.GatherOmega-NTuple{18, Any}","page":"IMSRG","title":"NuclearToolkit.GatherOmega","text":"GatherOmega(Omega,nOmega,gatherer,tmpOp,Nested,H0,Hs,ncomm,norms,Chan1b,Chan2bD,HFobj,IMSRGobj,dictMono,dict6j,PandyaObj,maxnormOmega,to)\n\nThis may not be used now.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.Get2bDenominator-NTuple{14, Any}","page":"IMSRG","title":"NuclearToolkit.Get2bDenominator","text":"Get2bDenominator(ch,pnrank,a,b,i,j,na,nb,ni,nj,f,Delta,dictMono,key;verbose=false)\n\nf_aa +f_bb f_ii f_jj +G_abij +Delta\n\nwith G_abij = Gamma_abab + Gamma_ijij - (Gamma_aiai + Gamma_bjbj + a leftrightarrow b)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.Gethhph-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.Gethhph","text":"Gethhph(kets,sps)\n\nget idxs for hh/ph kets\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.adhoc_rewrite6jdict","page":"IMSRG","title":"NuclearToolkit.adhoc_rewrite6jdict","text":"adhoc_rewrite6jdict(emax,dict6j,ofst_unit=1000)\n\nadhoc function to replace dict. for 6j-symbols:{ji,jj,J,jk,jl,J'} key = [ji,jj,jk,jl,J'] -> newkey::Int64 newdict is Vector for total J\n\n\n\n\n\n","category":"function"},{"location":"IMSRG.html#NuclearToolkit.calc_Eta_atan!-NTuple{5, Any}","page":"IMSRG","title":"NuclearToolkit.calc_Eta_atan!","text":"calc_Eta_atan!(HFobj,IMSRGobj,Chan2b,dictMono,norms)\n\ncalc. eta(s) with atan generator\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.check_order_Mkey-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.check_order_Mkey","text":"check_order_Mkey(key,pnrank)\n\nreorder key to be key[1] > key[2]\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.flow_Operators-NTuple{12, Any}","page":"IMSRG","title":"NuclearToolkit.flow_Operators","text":"flow_Operators(binfo,HFobj,IMSRGobj,PandyaObj,Chan1b,Chan2bD,dict_9j,HOBs,dictMono,dict6j,Operators,to)\n\nconsistent IMSRG flow of scaler operators (Rp2) using written Omega\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.generator_atan-NTuple{6, Any}","page":"IMSRG","title":"NuclearToolkit.generator_atan","text":"generatoratan     a: particle index     i: hole index     Gam: D'NO2B     iket:: index for |ai> to get Gam{aiai}=Gam[iket,iket]     Delta: parameter for energy shift like EKK\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.getNorm-NTuple{4, Any}","page":"IMSRG","title":"NuclearToolkit.getNorm","text":"getNorm(O,p_sps,n_sps,Chan2b)\n\nreturns sqrt(norm1b^2 + norm2b^2)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.getNorm1b","page":"IMSRG","title":"NuclearToolkit.getNorm1b","text":"getNorm1b(Mat1b,p_sps,n_sps,verbose=false)\n\nreturns 1bnorm of the given Operator\n\n\n\n\n\n","category":"function"},{"location":"IMSRG.html#NuclearToolkit.getNorm2b","page":"IMSRG","title":"NuclearToolkit.getNorm2b","text":"getNorm2b(Mat2b,Chan2b,verbose=false)\n\nreturns 2bnorm of the given Operator\n\n\n\n\n\n","category":"function"},{"location":"IMSRG.html#NuclearToolkit.imsrg_main-NTuple{11, Any}","page":"IMSRG","title":"NuclearToolkit.imsrg_main","text":"imsrg_main(binfo,Chan1b,Chan2bD,HFobj,dictMono,d9j,HOBs,dict6j,valencespace,Operators,to; core_generator_type=\"atan\",valence_generator_type=\"shell-model-atan\",denominatorDelta=0.0)\n\nArguments\n\nbinfo::basedat struct basedat(nuc::nuclei,sntf::String,hw::Float,emax::Int)\nChan1b::chan1b struct for one-body stuffs\nChan2bD::chan2bD struct for two-body stuffs (e.g., dict to get idx from JPT)\nHFobj::HamiltonianNormalOrdered struct HNO, which includes info. of HF solution (HF energy, occupation, f,Gamma,...)\ndictMono::Dict dictionary to get Vmonopole\nd9j preallocated dictionaries for wigner 9j symbols, which are needed to calculate Rp2\nHOBs struct HarmonicOscillatorBrackets \ndict6j preallocated dictionaries for wigner6j symbols (needed in e.g., Pandya transformation)\nvalencespace to specify valence space  \nOperators::Vector{String} non-Hamiltonian operators\nto TimerOutput object to measure runtime&memory allocations\n\nOptional Arguments\n\ncore_generator_type only the \"atan\" is implemented\nvalence_generator_type only the \"shell-model-atan\" is implemented\ndenominatorDelta::Float denominator Delta, which is needed for multi-major shell decoupling\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.init_IMSRGobject-Tuple{Any}","page":"IMSRG","title":"NuclearToolkit.init_IMSRGobject","text":"init_IMSRGobject(HFobj;smax=500.0,dsmax=0.5,maxnormOmega=0.25,tol=1.e-6,eta_criterion=1.e-6,denominatorDelta=0.0)\n\nConstructor for IMSRGobject\n\nH0::Operator for starting point of BCH product\nH::Operator Hamiltonian H(s)\ns::Vector{Float} current s and ds\nsmax::Float maximum s\ndsmax::Float maximum ds\nmaxnormOmega::Float maximum ||Omega||\neta::Operator generator of IMSRG flow (antihermite Operator)\nOmega::Operator generator of IMSRG flow (antihermite Operator) \neta_criterion::Float ||eta|| to check convergence\ndenominatorDelta::Float64 parameter for multi-major shell decoupling\nn_written_omega::Int # of written Omega by splitting to solve IMSRGflow\nNcomm::Vector{Int} # of commutator evaluated during IMSRG flow\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.init_dictMonopole!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.init_dictMonopole!","text":"init_dictMonopole!(dictMonopole,Chan2b)\n\ninitialize dictMonopole\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.make_PandyaKets-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.make_PandyaKets","text":"make_PandyaKets(emax,HFobj)\n\nTo prepare \"kets\" for Pandya transformation. For ordinary two-body channels, kets like |i,j=i;J=odd> where i={n,l,j,tz} are hindered, but necessary for Pandya transformation.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.prep_PandyaLookup-NTuple{4, Any}","page":"IMSRG","title":"NuclearToolkit.prep_PandyaLookup","text":"numbersPandya:[ch,nKetcc,nhh,nph] for ich (channel index of Chan2b_Pandya) \n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.print_flowstatus-NTuple{5, Any}","page":"IMSRG","title":"NuclearToolkit.print_flowstatus","text":"print_flowstatus(istep,s,ncomm,norms,IMSRGobj)\n\nprint flowstatus s,E0,1b&2b norm for Omega, 1b&2b norm for Eta, Ncomm, nwritten\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.read_imsrg_parameter!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.read_imsrg_parameter!","text":"read_imsrg_parameter!(fn,IMSRGobj)\n\nFunction to overwrite IMSRGobj from the parameter file fn.\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.read_omega_bin!","page":"IMSRG","title":"NuclearToolkit.read_omega_bin!","text":"read_omega_bin!(nw,Op,verbose=false)\n\nread written Omega file and update Op::Operator\n\n\n\n\n\n","category":"function"},{"location":"IMSRG.html#NuclearToolkit.set_dictMonopole!-Tuple{Any, Any, Any}","page":"IMSRG","title":"NuclearToolkit.set_dictMonopole!","text":"set_dictMonopole!(dictMonopole,HFobj,H)\n\nTo update dictMonopole pp/pn/nn under H(s=0)/IMSRG H(s)\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.set_sps_to_core!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.set_sps_to_core!","text":"set_sps_to_core!(binfo,HFobj)\n\nmodify p_sps.occ, n_sps.occ by the \"core\" nucleus\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.set_sps_to_modelspace!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.set_sps_to_modelspace!","text":"set_sps_to_modelspace!(binfo,HFobj)\n\nmodify occupation by specified model space\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.update_core_in_sps!-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.update_core_in_sps!","text":"update_core_in_sps!(binfo,HFobj)\n\nFunction to specify hole/core for sps. This will will be used for target normal ordering\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.write_omega_bin-Tuple{Any, Any, Any}","page":"IMSRG","title":"NuclearToolkit.write_omega_bin","text":"to write binary file for Operator flow using split/huntergatherer method\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.calc_Eta_smatan!-NTuple{5, Any}","page":"IMSRG","title":"NuclearToolkit.calc_Eta_smatan!","text":"calc_Eta_smatan!(HFobj,IMSRGobj,Chan2b,dictMono,norms)\n\neta(s) with shell-model atan generator to decouple valence space\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.check_major_valencespace-Tuple{String, Any, Any}","page":"IMSRG","title":"NuclearToolkit.check_major_valencespace","text":"check_major_valencespace(str::String,HFobj,v)\n\nFunction to check valence space and overwrite v and q fields of SingleParticleState The valencespace is specified by argument str (e.g. \"p-shell\") \n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.check_str_valencespace-Tuple{Vector{Vector{Int64}}, Any, Any}","page":"IMSRG","title":"NuclearToolkit.check_str_valencespace","text":"check_str_valencespace(valencespace::Vector{Vector{Int64}},HFobj,v)\n\ncheck valence space and overwrtie SingleParticleState.v/q\n\nspecified by or Vector{Int} (e.g., [[0,1,1,-1],[0,1,3,-1], [0,1,1,1],[0,1,3,1]])\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.check_valence_space-Tuple{Any, Any}","page":"IMSRG","title":"NuclearToolkit.check_valence_space","text":"check_valence_space(HFobj,valencespace)\n\ncheck validity of specified valence space\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.update_vsspace_chs!-Tuple{Any, Any, Any}","page":"IMSRG","title":"NuclearToolkit.update_vsspace_chs!","text":"update_vsspace_chs!(HFobj,valencespace,Chan2b)\n\noverwrite cc/vc/qc/vv/qv/qq channals\n\n\n\n\n\n","category":"method"},{"location":"IMSRG.html#NuclearToolkit.write_vs_snt-NTuple{8, Any}","page":"IMSRG","title":"NuclearToolkit.write_vs_snt","text":"write_vs_snt(binfo,HFobj,IMSRGobj,Operators,effOps,Chan1b,Chan2bD,vspace)\n\nFunction to write out valence space effective interaction in snt (KSHELL/ShellModel.jl) format.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#Hartreefock","page":"HartreeFock","title":"Hartreefock","text":"","category":"section"},{"location":"HartreeFock.html","page":"HartreeFock","title":"HartreeFock","text":"Functions for Hartree-Fock calculations.","category":"page"},{"location":"HartreeFock.html","page":"HartreeFock","title":"HartreeFock","text":"def_struct.jl: define struct/mutable struct  \nhf_mbpt.jl: calculate HFMBPT energy correction\nio_input.jl: I/O stuffs and read input (snt file)\nmain.jl: main functions\noperator.jl: (scaler) operators and normal ordering","category":"page"},{"location":"HartreeFock.html","page":"HartreeFock","title":"HartreeFock","text":"Modules = [NuclearToolkit]\nPages = [\"hartreefock.jl/def_struct.jl\",\n        \"hartreefock.jl/hf_mbpt.jl\",\n        \"hartreefock.jl/io_input.jl\",\n        \"hartreefock.jl/main.jl\",\n        \"hartreefock.jl/operator.jl\"]","category":"page"},{"location":"HartreeFock.html#NuclearToolkit.Chan2bD","page":"HartreeFock","title":"NuclearToolkit.Chan2bD","text":"struct chan2bD\n\nFields\n\nChan2b::Vector{chan2b} array of chan2b (ch=1,...,nchan)\ndict_ch_JPT::Dict{Vector{Int64},VdictCh} dict to get VdictCh by given key [J,prty,T]\ndict_ch_idx_from_ket::Vector{Vector{Dict{Vector{Int64},Vector{Vector{Int64}}}}} dict to get [ch,idx], having array structure [pnrank(=1/2/3)][J+1], key=ket\ndict_idx_from_chket::Vector{Dict{Vector{Int64},Int64}} dict to get idx from ket, having array structure [ch]\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.Dict1b","page":"HartreeFock","title":"NuclearToolkit.Dict1b","text":"struct Dict1b \n\nFields\n\nsnt2ms::Dict{Int64,Int64} map from snt idx to modelspace(ms) idx\nms2snt::Dict{Int64,Int64} map from ms idx to snt idxdef_struct.jl\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.HamiltonianNormalOrdered","page":"HartreeFock","title":"NuclearToolkit.HamiltonianNormalOrdered","text":"struct HamiltonianNormalOrdered\n\nFields\n\nH::Operator Hamiltonian operator\nE0::Float64 NO0B of H\nEMP2::Float64 PT2 correction to E0\nEMP3::Float64 PT3 correction to E0\nCp::Matrix{Float64} eigenvectors of hp, used unitary trans. HO=>HF basis (proton part)\nCn::Matrix{Float64} eigenvectors of hn, unitary trans. HO=>HF basis (neutron part)\ne1b_p::Vector{Float64} eigenvalues of hp\ne1b_n::Vector{Float64} eigenvalues of hn\nmodelspace::ModelSpace\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.HarmonicOscillatorBrackets","page":"HartreeFock","title":"NuclearToolkit.HarmonicOscillatorBrackets","text":"struct HarmonicOscillatorBrackets\n\nA hierarchical array of dictionaries reduces readability, but on the other hand a few hierarchical structures. It may reduce the time taken to traverse the elements...\n\nFields\n\ndict::Vector{Vector{Dict{Vector{Int64},Float64}}} dictionary for HOB [L][e2] #e2=2n+l+2N+L=2n1+l1+2n2+l2\nkey::Vector{Int64} \n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.IMSRGobject","page":"HartreeFock","title":"NuclearToolkit.IMSRGobject","text":"mutable struct IMSRGobject\n\nFields\n\nH0::Operator Hamiltonian for starting point of BCH product\nH::Operator Hamiltonian H(s)\ns::Vector{Float} current s and ds\nsmax::Float maximum s\ndsmax::Float maximum ds\nmaxnormOmega::Float maximum ||Omega||\neta::Operator generator of IMSRG flow (antihermite Operator)\nOmega::Operator generator of IMSRG flow (antihermite Operator) \neta_criterion::Float ||eta|| to check convergence\ndenominatorDelta::Float64 parameter for multi-major shell decoupling\nn_written_omega::Int # of written Omega by splitting to solve IMSRGflow\nNcomm::Vector{Int} # of commutator evaluated during IMSRG flow\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.ModelSpace","page":"HartreeFock","title":"NuclearToolkit.ModelSpace","text":"struct ModelSpace\n\nFields\n\np_sps::Vector{SingleParticleState} proton single particle states (only odd integer)\nn_sps::Vector{SingleParticleState} neutron single particle states\nsps::Vector{SingleParticleState} single particle states (odd number ones=>proton even=>neutron)\nocc_p::Matrix{Float64} matrix representing the occupation number of proton (needed for density matrix)\nocc_n::Matrix{Float64} matrix representing the occupation number of neutron\nholes::Vector{Vector{Int64}} idx list of holes\nparticles::Vector{Vector{Int64}} idx list of particles\nspaces::space_channel space_channel (mutable struct)\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.Operator","page":"HartreeFock","title":"NuclearToolkit.Operator","text":"mutable struct Operator\n\nFields\n\nzerobody::Vector{Float64} zerobody part of the operator\nonebody::Vector{Matrix{Float64}} one-body matrix elements ([1]=>proton, [2]=>neutron)\ntwobody::Vector{Matrix{Float64}} two-body matrix elements, having array structure [ch]\nhermite::Bool whether it is hermitian operator or not\nantihermite::Bool antihermitian or not\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.PandyaObject","page":"HartreeFock","title":"NuclearToolkit.PandyaObject","text":"struct PandyaObject, used for Pandya transformation (especially in comm222ph_ss!)\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.SingleParticleState","page":"HartreeFock","title":"NuclearToolkit.SingleParticleState","text":"mutable struct SingleParticleState\n\nFields\n\nn::Int64 principal quantum number of the single particle state(sps)\nl::Int64 azimuthal quantum number of the sps\nj::Int64 angular momentum\ntz::Int64 z-component of isospin (doubled) tz=-1 => proton & tz=1 => neutron\nocc::Int64 occupation number (0 or 1 for now, fractional occupation has not yet implemented) of the sps\nc::Bool indicating whether the single-particle state belongs to \"core\" or not \nv::Bool whether belongs to \"valence\" or not \nq::Bool whether belongs to \"q-space\" or not \n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.VdictCh","page":"HartreeFock","title":"NuclearToolkit.VdictCh","text":"struct VdictCh\n\nFields\n\nVch::Int64 two-body channel (specified by JPT)\nVdict::Dict{Vector{Int64},Int64} dict to get idx from ket like |1,5>:=[1,5]\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.basedat","page":"HartreeFock","title":"NuclearToolkit.basedat","text":"struct basedat contains base infomation of the calculation\n\nFields\n\nnuc::nuclei information of target/core nucleus \nsntf::String filename/path to input interaction\nhw::Int64 hbar omega parameter used to define single particle states\nemax::Int64 emax truncation for the entire calculations\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.chan1b","page":"HartreeFock","title":"NuclearToolkit.chan1b","text":"struct chan1b \n\nFields\n\nchs1b::Vector{Dict{Int64,Vector{Int64}}} dict of single particle states with non-zero contribution (having same l,j) [dict for proton sps, dict for neutron sps]\nchs1b_redundant::Vector{Dict{Int64,Vector{Int64}}} redundant version of chs1b (with i>j case)\nsnt2ms::Dict{Int64,Int64} map from snt idx to modelspace(ms) idx\nms2snt::Dict{Int64,Int64} map from ms idx to snt idx\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.chan2b","page":"HartreeFock","title":"NuclearToolkit.chan2b","text":"struct chan2b referred to as \"tbc\" (two-body channel) in some functions\n\nFields\n\nTz::Int64 total tz, -2(pp),0(pn),2(n)\nprty::Int64 parity\nJ::Int64 total J\nkets::Vector{Vector{Int64}} vector of ket (e.g. [1,1], [1,3],...)\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.dWS2n","page":"HartreeFock","title":"NuclearToolkit.dWS2n","text":"struct dWS2n, Wigner symbols used in PreCalcHOB\n\nFields\n\ndtri::Dict{Vector{Int64},Float64} dict for trinomial \ndcgm0::Dict{Vector{Int64},Float64} dict for special CG coefficients\nkeycg::Vector{Vector{Int64}} array of key for cg\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.dictSnt","page":"HartreeFock","title":"NuclearToolkit.dictSnt","text":"struct dictTBMEs contains dictionaries for TBME/monopole\n\nFields\n\ndictTBMEs::Vector{Dict{Vector{Int64},Float64}} one can get pp/pn/nn dict by dictTBMEs[pnrank] (pnrank=1,2,3)\ndictMonopole::Vector{Dict{Vector{Int64},valDictMonopole}} one can get monopole component of two-body interaction by dictMonopole[pnrank][key], key to be ket array like [1,1]\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.hfdata","page":"HartreeFock","title":"NuclearToolkit.hfdata","text":"struct hfdata, used to calculate multiple nuclei in a single runscript\n\nFields\n\nnuc::nuclei information of target/core nucleus\ndata::Vector{Vector{Float64}} will be experimental data from AME2020 (if available)\ndatatype::Vector{String} supposed to be [\"E\"] for now\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.nuclei","page":"HartreeFock","title":"NuclearToolkit.nuclei","text":"struct nuclei\n\nFields\n\nZ::Int64 proton number of the reference nucleus\nN::Int64 neutron number of the ref.\nA::Int64 mass number of the ref.\nel::String element (e.g., \"He\")\ncnuc::String string element nameA (e.g., \"He8\")\ncZ::Int64 proton number of core nucleus \ncN::Int64 neutron number of core\ncorenuc::String core nucleus (e.g., \"He4\")\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.single_util122","page":"HartreeFock","title":"NuclearToolkit.single_util122","text":"struct single_util122, used to make operation related commutator122 matrix manipulation\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.space_channel","page":"HartreeFock","title":"NuclearToolkit.space_channel","text":"mutable struct space_channel; dictionaries to get the two-body channels that have kets (specified by pp,ph, etc.)\n\nFields\n\npp::Dict{Int64,Vector{Int64}} particle-particle\nph::Dict{Int64,Vector{Int64}} particle-hole \nhh::Dict{Int64,Vector{Int64}} hole-hole\ncc::Dict{Int64,Vector{Int64}} core-core\nvc::Dict{Int64,Vector{Int64}} valence-core\nqc::Dict{Int64,Vector{Int64}} qspace-core\nvv::Dict{Int64,Vector{Int64}} valence-valence\nqv::Dict{Int64,Vector{Int64}} qspace-valence\nqq::Dict{Int64,Vector{Int64}} qspace-qspace\n\n\n\n\n\n","category":"type"},{"location":"HartreeFock.html#NuclearToolkit.HF_MBPT2-NTuple{8, Any}","page":"HartreeFock","title":"NuclearToolkit.HF_MBPT2","text":"HF_MBPT2(binfo,modelspace,fp,fn,e1b_p,e1b_n,Chan2b,Gamma)\n\nCalculate 2nd order correction to HF energy\n\nE^(2) = frac14sum_abij fracbarH^2_abij barH^2_ijabepsilon^ab_ij = frac14 sum_tildeatildebtildeitildejsum_msum_JJMM\nfrac^JbarH^2_tildeatildebtildeitildej ^JbarH^2_tildeitildejtildeatildebepsilon^ab_ij\n(j_a j_b m_a m_bJ M)\n(j_a j_b m_a m_bJ M)\n(j_i j_j m_i m_jJ M)\n(j_i j_j m_i m_jJ M)\n\n=\nfrac14 sum_tildeatildebtildeitildejsum_JJMM\nfrac^JbarH^2_tildeatildebtildeitildej ^JbarH^2_tildeitildejtildeatildebepsilon^ab_ij\ndelta_JJ delta_MM = frac14 sum_tildeatildebtildeitildejsum_J(2J+1)\nfrac^JbarH^2_tildeatildebtildeitildej ^JbarH^2_tildeitildejtildeatildebepsilon^ab_ij\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.HF_MBPT3-NTuple{9, Any}","page":"HartreeFock","title":"NuclearToolkit.HF_MBPT3","text":"HF_MBPT3(binfo,modelspace,e1b_p,e1b_n,Chan2b,dict_2b_ch,dict6j,Gamma,to)\n\nCalculate 2nd order correction to HF energy\n\nE^(3)=\nfrac18 \nsum_tildeatildebtildectildeitildejtildek sum_J(2J+1)\nfrac\n^JbarH^2_tildeatildebtildeitildej \n^JbarH^2_tildeitildejtildectilded\n^JbarH^2_tildectildedtildeatildeb \n\nepsilon^tildeatildeb_tildeitildejepsilon^tildectilded_tildeitildej\n+\nfrac18 \nsum_tildeatildebtildeitildejtildektildel sum_J(2J+1)\nfrac\n^JbarH^2_tildeitildejtildeatildeb \n^JbarH^2_tildeatildebtildektildel\n^JbarH^2_tildektildeltildeitildej \n\nepsilon^tildeatildeb_tildeitildejepsilon^tildectilded_tildeitildej\n-sum_tildeatildebtildectildeitildejtildek sum_J(2J+1)\nfrac\n^JH^XC_tildeatildeitildejtildeb\n^JH^XC_tildejtildebtildektildec\n^JH^XC_tildektildectildeatildei\n\nepsilon^tildeatildeb epsilon_tildeitildej\nepsilon^tildeatildec epsilon_tildektildej\n\n\nRef. Many-Body Methods in Chemistry and Physics by Isaiah Shavitt and Rodney J. Bartlett (2009, Cambridge Molecular Science). More details can be found in e.g. Dr. thesis by A.Tichai (2017, TU Darmstadt).\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.vPandya-NTuple{15, Any}","page":"HartreeFock","title":"NuclearToolkit.vPandya","text":"vPandya(a,b,c,d,ja,jb,jc,jd,totJ,dict_2b_ch,tdict6j,Gamma,keych,key6j,keyab;verbose=false)\n\nreturns generalized Pandya transformed matrix element:\n\ntildeV^J_ajib = -sum_J J \nbeginBmatrix \nj_a  j_j  J \nj_i  j_d  J\nendBmatrix\nV^J_abij\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.cZN_from_corenuc-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.cZN_from_corenuc","text":"cZN_from_corenuc(rZ,rN,corenuc)\n\nget Z and N of the core nucleus\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.def_chan1b-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.def_chan1b","text":"def_chan1b(dim1b,sps,dicts1b)\n\ndefine Chan1b: dict. to get 1b-channels to be coupled to a given channel Chan1b = [ dictforprotonsps, dictforneutronsps] dicts1b Basically ToBeCoupled will be used, but redundant one is needed in some cases\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.def_chan2b-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.def_chan2b","text":"def_chan2b(binfo,dicts,sps,Chan1b)\n\ndefine two-body utils and returns them as Chan2bD struct \n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.def_nuc-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.def_nuc","text":"def_nuc(Z,N,ref,corenuc)\n\nconstructor of nuclei strict from given Z,N,ref,corenuc\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.def_nuc-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.def_nuc","text":"def_nuc(Z,N,ref,corenuc)\n\nconstructor of nuclei strict from given cnuc,ref,corenuc\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.get_ZNref-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.get_ZNref","text":"get_ZNref(ref,Z,N,corenuc)\n\nget Z and N of the target reference\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.make_sps_and_dict_isnt2ims-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.make_sps_and_dict_isnt2ims","text":"make_sps_and_dict_isnt2ims(p_sps,n_sps,lp)\n\nmake dicts1b, snt-idx(sntidx) = 1-lp (proton) & lp+1~lp+ln (neutron), modelspace-idx(msidx) = odd(1,3,...)-> proton, even(2,4,...) -> neutron\n\nreturns:\n\ndict_snt2ms: from sntidx to msidx \ndict_ms2snt: from msidx to sntidx\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.make_sps_from_pnsps-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.make_sps_from_pnsps","text":"make_sps_from_pnsps(p_sps,n_sps,Chan1b)\n\nconstruct sps from p_sps and n_sps\n\nIt may be better to unify the rule whther sps to be constructed \"referring\" or \"copying\" psps/nsps. (For now it does not matter.)\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.readsnt-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.readsnt","text":"readsnt(sntf,binfo,to)\n\nFunction to read snt file. Note that it is slightly different from readsnt() in ShellModel.jl.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.readsnt_bin-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.readsnt_bin","text":"readsnt(sntf,binfo,to)\n\nFunction to read snt.bin file.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.rm_comment-Tuple{Any}","page":"HartreeFock","title":"NuclearToolkit.rm_comment","text":"rm_comment(lines)\n\nremove fortran like comment from input (snt fmt) strings\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.store_1b2b-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.store_1b2b","text":"store_1b2b(sps,dicts1b,dicts,binfo)\n\nFunction summarize data from input snt/snt.bin file.It returns\n\nHamil::Operator input interaction\ndictsnt dict to get TBMEs and monopole components\nChan1b struct chan1b\nChan2bD struct chan2b \nGamma preallocated two-body density matrices\nmaxnpq maximum size of length(kets) for two-body channels\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.update_1b!-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.update_1b!","text":"update_1b!(binfo,sps,Hamil)\n\nUpdate one-body(1b) part of Hamiltonian for different target nuclei\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.update_2b!-NTuple{6, Any}","page":"HartreeFock","title":"NuclearToolkit.update_2b!","text":"update_2b!(binfo,sps,Hamil,dictTBMEs,Chan2bD,dicts)\n\nUpdate two-body(2b) part of Hamiltonian for different target nuclei\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.ReorderHFSPS!-NTuple{7, Any}","page":"HartreeFock","title":"NuclearToolkit.ReorderHFSPS!","text":"ReorderHFSPS!(h_p,h_n,Cp,Cn,e1b_p,e1b_n,Chan1b)\n\n\"reorder\" HF single particle space. Since we diagonalize the h_p,h_n (istead of subblock mat), we need to specify the correspondance between ordering of sps and that of HFSPEs obtained by solving HF eigenvalue problem\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.add_ch_ket!-Tuple{Any, Any, Any}","page":"HartreeFock","title":"NuclearToolkit.add_ch_ket!","text":"add_ch_ket!(ch,iket,tdict)\n\nadd ch & idx for kets in spaces::space_channel (pp/hh/etc.)\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.calc_Gamma!-NTuple{7, Any}","page":"HartreeFock","title":"NuclearToolkit.calc_Gamma!","text":"calc_Gamma!(Gamma,sps,Cp,Cn,V2,Chan2b,maxnpq)\n\ncalculate Gamma (two-body HF interaction)\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.def_holeparticle-NTuple{5, Any}","page":"HartreeFock","title":"NuclearToolkit.def_holeparticle","text":"def_holeparticle(Chan1b,occ_p,occ_n,p_sps,n_sps)\n\ndefine hole/particle space by occ_p, occ_n\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.def_sps-Tuple{Any}","page":"HartreeFock","title":"NuclearToolkit.def_sps","text":"def_sps(emax)\n\nFunction to define sps::Vector{SingleParticleState} from emax. \n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.getHNO-Union{Tuple{tChan2b}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, tChan2b, Any, Any, Any, Any, Any}} where tChan2b<:Vector{NuclearToolkit.chan2b}","page":"HartreeFock","title":"NuclearToolkit.getHNO","text":"getHNO(binfo,tHFdata,E0,p_sps,n_sps,occ_p,occ_n,h_p,h_n,e1b_p,e1b_n,Cp,Cn,V2,Chan1b,Chan2b::tChan2b,Gamma,maxnpq,dict_2b_ch,dict6j,to) where{tChan2b <: Vector{chan2b}}\n\nobtain spherical HF solution and calc. MBPT correction (upto 2nd&3rd order) to g.s. energy\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.get_space_chs-Tuple{Any, Any}","page":"HartreeFock","title":"NuclearToolkit.get_space_chs","text":"get_space_chs(sps,Chan2b)\n\ndefine hole/particle single particle states. In this function, only the hh/pp/ph (needed for IMSRG) are defined, and other channels will be updated later for target normal ordering or VS-IMSRG flow.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.hf_iteration-NTuple{11, Any}","page":"HartreeFock","title":"NuclearToolkit.hf_iteration","text":"hf_iteration(binfo,tHFdata,sps,Hamil,dictTBMEs,Chan1b,Chan2bD,Gamma,maxnpq,dict6j,to;itnum=100,verbose=false,HFtol=1.e-14,inttype=\"snt\")\n\nsolve HF equation\n\nThis function returns object with HamiltonianNormalOrdered (HNO) struct type, which contains...\n\nE0,EMP2,EMP3 HF energy and its MBPT corrections\nfp/fn::Matrix{Float64} one-body int.\nGamma:: Vector{Matrix{Float64}} two-body int.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.hf_main-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.hf_main","text":"hf_main(nucs,sntf,hw,emax;verbose=false,Operators=String[],is_show=false,doIMSRG=false,valencespace=[],corenuc=\"\",ref=\"nucl\")\n\nmain function to carry out HF/HFMBPT calculation from snt file\n\nArguments\n\nnucs::Vector{String} target nuclei\nsntf path to input interaction file\nhw hbar omega\nemax emax for HF/IMSRG\n\nOptional Arguments\n\nverbose=false to see detailed stdout for HF\nOperators=String[] target observables other than Hamiltonian\nis_show=false to show TimerOutput log (summary of run time and memory allocation)\ndoIMSRG=false to carry out IMSRG/VSIMSRG calculation \nvalencespace=[] to spacify the valence space (e.g., [\"sd-shell\"]), if this is not empty, it tries to do vsimsrg calculations\ncorenuc=\"\" core nucleus, example=> \"He4\"\nref=\"nucl\" to specify target reference state, \"core\" or \"nucl\" is supported\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.hf_main_mem-NTuple{6, Any}","page":"HartreeFock","title":"NuclearToolkit.hf_main_mem","text":"hf_main_mem(chiEFTobj,nucs,dict_TM,dict6j,HFdata,to;verbose=false,Operators=String[],valencespace=[],corenuc=\"\",ref=\"core\")\n\n\"without I/O\" version of hf_main\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.ini_occ!-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.ini_occ!","text":"ini_occ!(pconfs,occ_p,nconfs,occ_n)\n\ninitialize occupation number matrices (occ_p&occ_n) by naive filling configurations pconfs&nconfs\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.naive_filling","page":"HartreeFock","title":"NuclearToolkit.naive_filling","text":"naive_filling(sps,n_target,emax,for_ref=false)\n\ncalculate naive filling configurations by given sps and proton/neutron number (n_target)\n\nFor some nuclei, carrying out naive filling is ambiguous (e.g., neutron occupation of 22O can be both 0s1(2),0p1(2),0p3(4),0d5(6) and  0s1(2),0p1(2),0p3(4),1s1(2), 0d3(4)). In this function, \"naive filling\" means to try fill orbits with lower 2n+l and then \"lower\" j. The occupations will be updated when solving HF.\n\n\n\n\n\n","category":"function"},{"location":"HartreeFock.html#NuclearToolkit.prepHFdata-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.prepHFdata","text":"prepHFdata(nucs,ref,datatype,corenuc)\n\nConstructor of an array of hfdata struct.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.printEHF-Tuple{Any}","page":"HartreeFock","title":"NuclearToolkit.printEHF","text":"printEHF(Es)\n\nprint HF energy and its break down Es=[E1b,E2bpp,E2bnn,E2bpn]\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.recalc_v!-Tuple{Any, Any}","page":"HartreeFock","title":"NuclearToolkit.recalc_v!","text":"recalc_v!(A,dicts)\n\nFunction to calculate two-body interaction from snt file. This is needed because in the readsnt/readsnt_bin function, the interaction part and the kinetic term  are stored separately to avoid multiple reads of the input file when calculating multiple nuclei.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.update_occ!-NTuple{8, Any}","page":"HartreeFock","title":"NuclearToolkit.update_occ!","text":"update_occ!(pconfs,nconfs,p_sps,n_sps,occ_p,occ_n,e1b_p,e1b_n)\n\nupdate occupation matrices by HF SPEs\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.Calc_Expec-NTuple{7, Any}","page":"HartreeFock","title":"NuclearToolkit.Calc_Expec","text":"Calc_Expec(binfo,Chan1b,Chan2b,HFobj,Op_Rp2,dict_2b_ch,dict6j;hfmbptlevel=true,verbose=false)\n\nCalculate expectation value of Rp2 and its HFMBPT corrections.\n\nDetails about HFMBPT correction can be found in  Many-Body Methods in Chemistry and Physics by Isaiah Shavitt and Rodney J. Bartlett (2009, Cambridge Molecular Science)  or Appendix in T. Miyagi et al., Phys. Rev. C 105, 0143022 (2022).\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.Calculate_RCM-NTuple{8, Any}","page":"HartreeFock","title":"NuclearToolkit.Calculate_RCM","text":"Calculate_RCM(binfo,Chan1b,Chan2b,HFobj,Op_Rp2,d9j,HOBs,to;non0_cm=true,non0_ij=true)\n\ncalculate R_CM term\n\nNote that rirj term is also included here to avoid redundancy.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.Calculate_Rp-NTuple{10, Any}","page":"HartreeFock","title":"NuclearToolkit.Calculate_Rp","text":"Calculate_Rp(binfo,Chan1b,Chan2b,HFobj,Op_Rp2,dict_9j_2n,HOBs,dict_2b_ch,dict6j,to;hfmbptlevel=true)\n\nTo calculate squared point proton radius and its MBPT correction. The squared point proton radius is related to the charge radius as follows\n\nR^2_ch = R^2_p + langle r^2_p rangle + fracNZ langle r^2_n rangle + frac34m^2_p c^4 \n+ langle r^2 rangle_SO\n\nwhere langle r^2_p rangle = 0769 mathrmfm^2, langle r^2_n rangle = -0116 mathrmfm^2, frac34m^2_p c^4 =0033mathrmfm^2 is the so-called Darwin-Foldy term, and the last term is Spin-Orbit correction term.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.Calculate_SOterm-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.Calculate_SOterm","text":"Calculate_SOterm(binfo,Chan1b,HFobj,Op_Rp2)\n\nCalculate Spin-Orbit Correction term for Rp2. We are using \"simple expression for the correction to the mean-square charge radius due to the spin-orbit term\" in the reference below:\n\nlangle r^2 rangle_SO =-frac1Zsum_i fracmu_iM^2 (kappa_i+1)\n\nwhere mu_p = 2793 mu_N, mu_n = 1913mu_N, and kappa = ell (mathrmfor  j=ell-12) -(ell+1) (mathrmfor j=ell+12)\n\nRef: A.Ong, J.C.Berengut, and V.V.Flambaum, Phys. Rev. C 82, 014320 (2010).\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.Calculate_intR2p-NTuple{4, Any}","page":"HartreeFock","title":"NuclearToolkit.Calculate_intR2p","text":"Calculate_intR2p(binfo,Chan1b,HFobj,Op_Rp2)\n\ncalculate a part of squared point proton radius R2p. Note that this function overwrites the onebody part of given Op_Rp2.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.InitOp-Tuple{Any, Any}","page":"HartreeFock","title":"NuclearToolkit.InitOp","text":"InitOp(Chan1b,Chan2b)\n\ninitialize scaler Operator, note that hermite is true as default\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.aOp!-Tuple{NuclearToolkit.Operator, Float64}","page":"HartreeFock","title":"NuclearToolkit.aOp!","text":"aOp!(Op::Operator,a::Float64)\n\nfunction to multiply scaler to an operator::Operator\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.aOp1_p_bOp2!-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64}","page":"HartreeFock","title":"NuclearToolkit.aOp1_p_bOp2!","text":"aOp1_p_bOp2!(Op1::Operator,Op2::Operator,a::Float64,b::Float64)\n\nfunction to overwrite Op2 by a*Op1 + b*Op2\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.aOp1_p_bOp2_Op3!-Tuple{NuclearToolkit.Operator, NuclearToolkit.Operator, NuclearToolkit.Operator, Float64, Float64, Float64}","page":"HartreeFock","title":"NuclearToolkit.aOp1_p_bOp2_Op3!","text":"aOp1_p_bOp2_Op3!(Op1::Operator,Op2::Operator,Op3::Operator,a::Float64,b::Float64,c::Float64)\n\nfunction to overwrite Op3 by c*Op3 + a*Op1 + b*Op2\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.calc_single_r1r2-NTuple{8, Any}","page":"HartreeFock","title":"NuclearToolkit.calc_single_r1r2","text":"calc_single_r1r2(bra,ket,sps,J,dict_9j_2n,HOBs,b2,to)\n\nCalc r_1 cdot r_2 for a given 2b-channel.\n\nbra: <ab| a&b: s.p.s. (n,l,j,tz)\nket: |cd> c&d: s.p.s. (n,l,j,tz)\ndictWS: dict of WignerSymobls\nd9j: 9j-symbols (array of J->S and key=[la,ja,lb,jb,L])\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.eval_rch_hfmbpt-NTuple{9, Any}","page":"HartreeFock","title":"NuclearToolkit.eval_rch_hfmbpt","text":"eval_rch_hfmbpt(binfo,Chan1b,Chan2bD,HFobj,Op_Rp2,dict_9j_2n,HOBs,dict6j,to)\n\nevaluate charge radii with HFMBPT\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.eval_rch_imsrg-NTuple{11, Any}","page":"HartreeFock","title":"NuclearToolkit.eval_rch_imsrg","text":"eval_rch_imsrg(binfo,Chan1b,Chan2bD,HFobj,IMSRGobj,PandyaObj,dict_9j_2n,HOBs,dictMono,dict6j,to)\n\nevaluate charge radii with IMSRG.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.getNormalOrderedO-NTuple{7, Any}","page":"HartreeFock","title":"NuclearToolkit.getNormalOrderedO","text":"getNormalOrderedO(binfo,HFobj,targetOp,Chan1b,Chan2bD,dict6j,to;verbose=false,undo=false,OpeqH=false,firstNO=false)\n\nNormalOrdering for a target Operator. For now, it only supports scaler operators.\n\n\n\n\n\n","category":"method"},{"location":"HartreeFock.html#NuclearToolkit.show_Hamil_norm-Tuple{NuclearToolkit.Operator}","page":"HartreeFock","title":"NuclearToolkit.show_Hamil_norm","text":"show_Hamil_norm(Op::Operator;tol=1.e-6,normtype=\"fro\")\n\nFunction to show 1b/2b norm of a given Operator. It may be usuful for debug.\n\n\n\n\n\n","category":"method"},{"location":"ShellModel.html#ShellModel","page":"ShellModel","title":"ShellModel","text":"","category":"section"},{"location":"ShellModel.html","page":"ShellModel","title":"ShellModel","text":"Functions for shell-model calculations","category":"page"},{"location":"ShellModel.html","page":"ShellModel","title":"ShellModel","text":"shellmodel_main.jl: contains main and util functions \nlanczos_methods.jl: Lanczos methods\ntransit.jl: EM transitions\ninputintsnt.jl: I/O stuffs\neigenvector_continuation.jl: eigenvector continuation to sample and construct shell-model wavefunctions","category":"page"},{"location":"ShellModel.html","page":"ShellModel","title":"ShellModel","text":"Modules = [NuclearToolkit]\nPages = [\"ShellModel/shellmodel_main.jl\",\n         \"ShellModel/lanczos_methods.jl\",\n         \"ShellModel/transit.jl\",\n         \"ShellModel/input_int_snt.jl\",\n         \"eigenvector_continuation.jl\"]\n","category":"page"},{"location":"ShellModel.html#NuclearToolkit.HbitT1-Tuple{Array{Vector{Int64}}, Array{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Vector{Vector{Int64}}}, Array{Vector{Float64}}}","page":"ShellModel","title":"NuclearToolkit.HbitT1","text":"function HbitT1(p_sps::Array{Array{Int64,1}},n_sps::Array{Array{Int64,1}},\n            mstates_p::Array{Array{Int64,1},1},mstates_n::Array{Array{Int64,1},1},\n            labels::Array{Array{Array{Int64,1},1},1},TBMEs::Array{Array{Float64,1}})\n\nmake bit representation of T=1 (proton-proton&neutron-neutron) interactions for each {m_z}\n\n\n\n\n\n","category":"method"},{"location":"ShellModel.html#NuclearToolkit.Hbitpn","page":"ShellModel","title":"NuclearToolkit.Hbitpn","text":"Hbitpn(p_sps::Array{Array{Int64,1}},n_sps::Array{Array{Int64,1}},\n       mstates_p::Array{Array{Int64,1},1},mstates_n::Array{Array{Int64,1},1},\n       labels::Array{Array{Int64,1}},TBMEs::Array{Float64,1},zeroME=false)\n\nmake bit representation of T=0 (proton-neutron) interactions for each {m_z}\n\n\n\n\n\n","category":"function"},{"location":"ShellModel.html#NuclearToolkit.all_perm!-Tuple{Int64, Int64, Array{Vector{Bool}}}","page":"ShellModel","title":"NuclearToolkit.all_perm!","text":"all_perm!(ln::Int64,num_valence::Int64,occs::Array{Array{Bool,1}})\n\nmake all possible permutation of 'bits'\n\nExample: If 2 protons and 1 neutron are in the 0p-shell space, valence orbits(0p1/2,0p3/2) => -1/2, 1/2, -3/2, -1/2, 1/2, 3/2\n\nconfigurations are represented like:\n\nproton: 000011, 000101, ..., 110000\n\nneutron: 000001, 000010, ..., 100000\n\n\n\n\n\n","category":"method"},{"location":"ShellModel.html#NuclearToolkit.def_mstates-Tuple{Any, Any}","page":"ShellModel","title":"NuclearToolkit.def_mstates","text":"defmstates(psps,n_sps)\n\nto define the single particle states specified by m_z\n\n\n\n\n\n","category":"method"},{"location":"ShellModel.html#NuclearToolkit.main_sm-NTuple{4, Any}","page":"ShellModel","title":"NuclearToolkit.main_sm","text":"mainsm(sntf,targetnuc,numev,targetJ;         savewav=false,q=1,isblock=false,isshow=false,numhistory=3,lm=100,ls=20,tol=1.e-6,         inwf=\"\",mdimmode=false,calcmoment = false,gfactors = [1.0,0.0,5.586,-3.826],effcharge=[1.5,0.5])\n\nDigonalize the model-space Hamiltonian \n\nArguments:\n\nsntf:       path to input interaction file (.snt fmt)\ntarget_nuc: target nucleus\nnum_ev:     number of eigenstates to be evaluated\ntarget_J:   target total J (specified by e.g. [0]). Set to [] if you want lowest states with any J.   Note that J should be doubled (J=0=>[0], J=1/2=>[1], J=1=>[2],...) \n\nOptional arguments:\n\nq=1              block size for Block-Lanczos methods \nis_block=false   whether or not to use Block algorithm \nsave_wav=false   whether or not to save wavefunction file \nis_show = true   to show elapsed time & allocations \nlm = 100         number of Lanczos vectors to store \nls = 15          number of vectors to be used for Thick-Restart \ntol= 1.e-6       tolerance for convergence check in the Lanczos method \nin_wf=\"\"      path to initial w.f. (for preprocessing) \nmdimmode=false   true => calculate only the M-scheme dimension\ncalc_moment=false  true => calculate mu&Q moments \ngfactors=[1.0,0.0,5.586,-3.826] angular momentum and spin g-factors \neffcgarge=[1.5,0.5] effective charges \n\n\n\n\n\n","category":"method"},{"location":"ShellModel.html#NuclearToolkit.occ-Tuple{Array{Vector{Int64}}, Array{Vector{Int64}}, Vector{Int64}, Int64, Array{Vector{Int64}}, Array{Vector{Int64}}, Vector{Int64}, Int64, Int64}","page":"ShellModel","title":"NuclearToolkit.occ","text":"occ(p_sps::Array{Array{Int64,1}},mstates_p::Array{Array{Int64,1}},mzp::Array{Int64,1},num_vp::Int64,\n    n_sps::Array{Array{Int64,1}},mstates_n::Array{Array{Int64,1}},mzn::Array{Int64,1},num_vn::Int64,Mtot::Int64)\n\nprepare bit representations of proton/neutron Slater determinants => pbits/nbits\n\njoccp, joccn: corresponding occupation numbers for a \"j\" state,   which is used for one-body operation and OBTDs.  \n\nMps/Mns: total M for proton/neutron \"blocks\"\n\nFor 6Li in the p shell and M=0, Mps = [-3,-1,1,3] & Mns = [3,1,-1,-3]   blocks => [ (Mp,Mn)=(-3,3),(Mp,Mn)=(-1,1),...]  \n\ntdims: array of cumulative number of M-scheme dimensions for \"blocks\"  \n\ntdims =[ # of possible configurations of (-3,3),            # of possible configurations of (-1,1),...]  \n\n\n\n\n\n","category":"method"},{"location":"ShellModel.html#NuclearToolkit.readsmsnt-Tuple{Any, Any}","page":"ShellModel","title":"NuclearToolkit.readsmsnt","text":"readsmsnt(sntf,Anum)\n\nTo read interaction file in \".snt\" format.\n\nsntf: path to the interaction file\nAnum: mass number (used for \"scaling\" of TBMEs)\n\nnote: Note\nThe current version supports only \"properly ordered\" interaction file in .snt format.A .snt file can be ordered to be a<=b,c<=d,a<=c for V(abcd;J) by the Python script \"ShellModel.jl/src/makeorderedsnt.py\"(, which will be replaced by Julia implementation...).\n\n\n\n\n\n","category":"method"},{"location":"ShellModel.html#NuclearToolkit.transit_main-NTuple{5, Any}","page":"ShellModel","title":"NuclearToolkit.transit_main","text":"transit_main(sntf,target_nuc,jl2,jr2,in_wfs;\n             num_ev_l=100,num_ev_r=100,q=1,is_block=false,is_show=true,\n             calc_EM=true,gfactors=[1.0,0.0,5.586,-3.826],eff_charge=[1.5,0.5])\n\nCalculate the M1&E2 transitions for two wavefunctions\n\nArguments\n\nsntf:path to the interaction file\ntarget_nuc:target nucleus in string e.g., \"Si28\"\njl2:J*2 for the left w.f.\njr2:J*2 for the right w.f.\nin_wfs:[\"path to left wf\",\"path to right wf\"]\n\nOptional arguments\n\nnum_ev_l=100:upper limit of the number of eigenvectors for the left w.f.\nnum_ev_r=100:upper limit of the number of eigenvectors for the right w.f.\nis_show=true:to display the TimerOutput\ngfactors=[1.0,0.0,5.586,-3.826]:g factors [glp,gln,gsp,gsn]\neff_charge=[1.5,0.5]:effective charges [ep,en]\n\nOptional arguments (not used, but for future developments)\n\nq=1:block size\nis_block=false:to use Block algorithm\n\n\n\n\n\n","category":"method"},{"location":"ShellModel.html#NuclearToolkit.solveEC-Tuple{Any, Any, Any}","page":"ShellModel","title":"NuclearToolkit.solveEC","text":"solveEC(Hs,target_nuc,tJNs;\n        write_appwav=false,verbose=false,calc_moment=true,wpath=\"./\",is_show=false,\n        gfactors = [1.0,0.0,5.586,-3.826],effcharge=[1.5,0.5],exact_logf=\"\")\n\nTo solve EC (generalized eigenvalue problem) to approximate the eigenpairs for a given interaction.\n\nH vecv = lambda N vecv\n\nTransition densities and overlap matrix for H and N are read from \"tdmat/\" directory (To be changed to more flexible)\n\nArguments:\n\nHs:array of paths to interaction files (.snt fmt)\ntarget_nuc: target nucleus\ntJNs:array of target total J (doubled) and number of eigenstates to be evaluated   e.g., [ [0,5], [2,5] ], when you want five lowest J=0 and J=1 states.\n\nOptional arguments:\n\nwrite_appwav=false:write out the approximate wavefunction\nverbose=false:to print (stdout) approx. energies for each interaction\ncalc_moment=true: to calculate mu&Q moments\nwpath=\"./\": path to sample eigenvectors to construct approx. w.f.\nis_show=false: to show TimerOutput\ngfactors=[1.0,0.0,5.586,-3.826]: g-factors to evaluate moments\neffcharge=[1.5,0.5]:effective charges to evaluate moments\n\nOptional arguments for author's own purpose\n\nexact_logf=\"\":path to logfile for E(EC) vs E(Exact) plot\n\nnote: Note\nAll the effective interactions must be in \"the same order\" and must be consistent with interaction file from which the transition density matrices were made.\n\n\n\n\n\n","category":"method"},{"location":"index.html#NuclearToolkit","page":"Home","title":"NuclearToolkit","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Julia Toolkit for nuclear structure calculations","category":"page"},{"location":"index.html#Installation-and-example","page":"Home","title":"Installation and example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"First, prepare Julia environment v >= 1.6.  ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Second, add the package in Pkg mode","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia>]add NuclearToolkit","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note: The above is currently not working, since this package has not yet registered as an official package.   The adhoc prescription for now is to execute below","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia src/package_install.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A sample script provided to perform","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"calculating NN potential by Chiral EFT\nHFMBPT(3) and IMSRG/VS-IMSRG(2) calculation\nshell-model calculations with the derived interaction by VS-IMSRG","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"in sequence. One can try as follows","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia -t 8 sample_script.jl","category":"page"},{"location":"index.html#Package-features-and-building-blocks","page":"Home","title":"Package features and building blocks","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"NuclearToolkit.jl provides a self-contained set of nuclear structure calculation codes covering from nuclear force to many-body methods (HF/HFMBPT, IM-SRG/VS-IMSRG, shell model, etc.).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"One of the main motivations for the author to develop NuclearToolkit.jl is, of course, for their own research purposes, and another one is for educational purpose. A single nuclear structure calculation code often contains tens of thousands to nearly 100,000 lines. In the author's personal opinion, it would be too difficult, students (especially in undergraduate or two-year master course), to understand the technical details of the latest nuclear many-body methods while reading the enormous length of existing codes in the community.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The author thought the Julia language can be a game changer to this situation with its high readbility, portabillity, and performance. There is no more need to prepare different Makefiles for different environments or worry about library dependencies. You can work equally well on a laptop or a supercomputer. While NuclearToolkit covers a wide range of methods, the overall code length is still in a few tens of thousands, including \"docstring\" to generate the document.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ChiEFTint: NN interaction from Chiral EFT ~ 5,000 lines.\nEntem & Machleidt N3L0\nDensity-Dependent NN from 3NF\n\"Valence\" NO\nHartreefock: Hartree-Fock (HF) and HF Many-Body Perturbation Theory (HFMBPT)  ~ 3,000 lines.\nEnergy (up to 3rd order)\nScaler operator (up to 2nd order)\nIMSRG: In-medium Similarity Renormalization Group (IMSRG)  ~ 2,000 lines.\nIMSRG(2) calc. for ground state energy\nconsistent IMSRG(2) flow of (scaler) operator\nValence-space IMSRG (VS-IMSRG)\nderive effective interaction for shell-model calculations\nconsistent VSIMSRG flow to get effective operators \nShellModel.jl ~ 5,000 lines. This was originally developed as an independent package.\nshell model calculations\nconstruct approximate wavefunctions with eigenvector continuation ","category":"page"},{"location":"index.html#Issues/Pull-requests","page":"Home","title":"Issues/Pull requests","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"NuclearToolkit.jl is designed to be an open-source software and to guarantee reproducibility and transparancy of future works. Making issues and pull requests are fully welcome.","category":"page"}]
}
